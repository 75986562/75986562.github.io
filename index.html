<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="萌面超人">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="萌面超人">
<meta property="og:description" content="个人学习博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="萌面超人">
<meta name="twitter:description" content="个人学习博客">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>萌面超人</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萌面超人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">
    <a href="/404/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/JAVA类加载和反射介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/JAVA类加载和反射介绍/" itemprop="url">
                  JAVA类加载和反射介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-19 21:37:30" itemprop="dateCreated datePublished" datetime="2019-02-19T21:37:30+08:00">2019-02-19</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="JAVA类加载和反射介绍"><a href="#JAVA类加载和反射介绍" class="headerlink" title="JAVA类加载和反射介绍"></a>JAVA类加载和反射介绍</h1><h2 id="JAVA类加载和反射简介"><a href="#JAVA类加载和反射简介" class="headerlink" title="JAVA类加载和反射简介"></a>JAVA类加载和反射简介</h2><p>简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息.</p>
<p>那么反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载。</p>
<h3 id="Java反射的作用"><a href="#Java反射的作用" class="headerlink" title="Java反射的作用"></a>Java反射的作用</h3><p>在Java运行时环境中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射（Reflection）机制。</p>
<blockquote>
<p>Java的反射机制的实现要借助于4个类：class，Constructor，Field，Method;</p>
</blockquote>
<p>Java 反射机制主要提供了以下功能：  </p>
<ol>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法</li>
</ol>
<p>其中class代表的是类对象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象，通过这四个对象我们可以粗略的看到一个类的各个组成部分。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4face8109e0d52ef5894c41c69e4ec6b_hd.jpg" alt="反射详解图"></p>
<p>当程序主动使用某个类时，若该类还没加载到内存中，系统会通过<strong>加载，链接，初始化</strong>3个操作对类进行初始化。<br>类字面常量”,class”创建Class对象的引用时，不会自动地初始化该Class对象，准备工作包含3个步骤:</p>
<ol>
<li><strong>加载</strong>:由类加载器执行，该步骤查找字节码,并从这些字节码中创建一个Class对象</li>
<li><strong>链接</strong>:在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。</li>
<li><strong>初始化</strong>:如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块</li>
</ol>
<h3 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h3><ol>
<li>创建类的实例</li>
<li>访问类或接口的静态变量（static final常量除外，static final变量可以）</li>
<li>调用类的静态方法</li>
<li>反射（Class.forName(packageName.className)）</li>
<li>初始化类的子类（子类初始化问题：满足主动调用，即访问子类中的静态变量、方法，否则仅父类初始化）</li>
<li>java虚拟机启动时被标明为启动类的类</li>
</ol>
<p>注：加载顺序：启动类的static block最先加载<br>(<code>父类静态成员、静态代码块</code>—&gt;<code>子类静态成员、静态代码块</code>—&gt;<code>父类实例成员、代码块</code>——&gt;<code>父类构造函数</code>—&gt;<code>子类实例成员、代码块</code>—&gt;<code>子类构造函数</code>)</p>
<p>我们需要明白在JAVA中任何class都要装载在虚拟机上才能运行，而forClass就是装载类用的，这是要和new不一样，要分清楚哦。<br><code>A a = (A)Class.forName(“package.A”).newInstance();</code>和 <code>A a = new A;</code>是等价的。<br>记住一个概念，静态代码是和class绑定的,class装载成功就表示执行了你的静态代码，而且以后不会再走这套静态代码了。<br>Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也即是说JVM会执行该类的静态代码段。</p>
<p>JAVA中获取Class对象有3种方式:</p>
<ol>
<li>Class.forName()</li>
<li>Object.getClass()</li>
<li>类字面常量 xx.class</li>
<li><h3 id="反射常用函数"><a href="#反射常用函数" class="headerlink" title="反射常用函数"></a>反射常用函数</h3></li>
</ol>
<p><strong>得到构造器的方法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaConstructor getConstructor(Class[] params) -- 获得使用特殊的参数类型的公共构造函数， </span><br><span class="line"></span><br><span class="line">Constructor[] getConstructors() -- 获得类的所有公共构造函数 </span><br><span class="line"> </span><br><span class="line">Constructor getDeclaredConstructor(Class[] params) -- 获得使用特定参数类型的构造函数(与接入级别无关) </span><br><span class="line"> </span><br><span class="line">Constructor[] getDeclaredConstructors() -- 获得类的所有构造函数(与接入级别无关)</span><br></pre></td></tr></table></figure></p>
<p><strong>获得字段信息的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> -- 获得命名的公共字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span> -- 获得类的所有公共字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> -- 获得类声明的命名的字段 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span> -- 获得类声明的所有字段</span></span><br></pre></td></tr></table></figure></p>
<p><strong>获得方法信息的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特定的参数类型，获得命名的公共方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> -- 获得类的所有公共方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class[] params)</span> -- 使用特写的参数类型，获得类声明的命名的方法 </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> -- 获得类声明的所有方法</span></span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://www.cnblogs.com/lijunamneg/archive/2013/03/25/2980991.html" target="_blank" rel="noopener">JAVA类加载和反射介绍</a></p>
<p>[2] <a href="https://www.zhihu.com/question/24304289" target="_blank" rel="noopener">学习java应该如何理解反射？<br>-知乎</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/Head First设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/Head First设计模式/" itemprop="url">
                  Head First设计模式1-9
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-18 16:37:30" itemprop="dateCreated datePublished" datetime="2019-01-18T16:37:30+08:00">2019-01-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-15 21:20:30" itemprop="dateModified" datetime="2019-02-15T21:20:30+08:00">2019-02-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="Head-First-设计模式1-9"><a href="#Head-First-设计模式1-9" class="headerlink" title="Head First 设计模式1-9"></a>Head First 设计模式1-9</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>封装变化。 </li>
<li>面向接口编程而非实现。</li>
<li>优先使用组合而非继承。 </li>
<li>为了交互对象之间的松耦合设计而努力。</li>
<li>类应该对扩展开放，对修改关闭。</li>
<li>依赖倒置原则，要依赖抽象，不要依赖具体类。</li>
<li>最少知识原则</li>
<li>好莱坞原则</li>
</ol>
<h2 id="模式类型"><a href="#模式类型" class="headerlink" title="模式类型"></a>模式类型</h2><h3 id="类型归集"><a href="#类型归集" class="headerlink" title="类型归集"></a>类型归集</h3><ol>
<li>OO模式</li>
<li>观察者模式</li>
<li>装饰者模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>命令模式</li>
<li>模板方法模式</li>
<li>组合模式</li>
</ol>
<h3 id="OO模式"><a href="#OO模式" class="headerlink" title="OO模式"></a>OO模式</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。</p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>策略模式定义了算法族，分别封装起来让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
<h4 id="setChange-函数"><a href="#setChange-函数" class="headerlink" title="setChange()函数"></a>setChange()函数</h4><p>setChanged()方法可以让你在更新观察者时，有更多的弹性，你可以更<br>适当地通知观察者。让你可以在函数需要的时候再通知，而不是一有变化就通知。</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p>通常装饰者模式是采用抽象类，但是在Java中可以使用接口。尽管如此，通常我们都努力<br>避免修改现有的代码，所以，如果抽象类运作得好好的，还是别去修改它。</p>
<p>装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式实现了生成产品类的代码跟客户端代码分离，在工厂类中你可以添加所需的生成产品的逻辑代码，但是问题来了，优秀的java代码是符合“开放-封闭”原则的，也就是说对扩展开发，对修改关闭，如果你要加一个产品类C，你就要修改工厂类里面的生成产品的代码，在这里你就要增加if-else判断。对于这个问题，我们的工厂方法模式就可以解决这个问题。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>隐藏具体实现</li>
<li>解耦</li>
<li>简单<br><strong>缺点</strong>：</li>
<li>扩展麻烦，需要改动现有的代码</li>
<li>孤注一掷，所有的逻辑都放在一个工厂里面，一旦这个类出现什么问题，那么就全GG </li>
</ul>
<h4 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p>产品和工厂分离，它把工厂也抽象出一个接口来；它让一个工厂只负责生产一种产品；</p>
<p><strong>优点</strong>：</p>
<ul>
<li>隐藏具体实现</li>
<li>解耦</li>
<li>简单</li>
<li>扩展方便。</li>
<li><strong>缺点</strong>：</li>
<li>增加系统的负担</li>
<li>代码量剧增</li>
<li>一个工厂只能生产一个产品</li>
</ul>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><strong>优点</strong>：</p>
<ul>
<li>隐藏具体实现</li>
<li>解耦</li>
<li>简单</li>
<li>扩展产品结构的时候，多个产品类，只需要写一个工厂类</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>扩展 <code>产品族</code> 很费劲 </li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>确保一个类只有一个实例，并提供一个全局访问点。</p>
<p><strong>关键点：构造函数是私有的</strong></p>
<p>在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例的模式；</p>
<h4 id="单件模式和全局变量比较"><a href="#单件模式和全局变量比较" class="headerlink" title="单件模式和全局变量比较"></a>单件模式和全局变量比较</h4><p>急切实例化VS,延迟实例化。</p>
<p>全局变量可以提供全局访问，但是不能确保只有一个实例。全局变量也会变相鼓励开发人员，用许多全局变量指向许多小对象来造成命名空间的污染，单件不鼓励这样的现象，但单件任然可能被滥用。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>定义：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
<p>设计空对象，表示什么都不做，这种设计可以免去一些校验操作。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式：将一个类的接口转换成客户希望的另一个接口</p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>提供一个统一的接口，用来访问子系统中的一群接口。外观定义一个高层接口，让子系统更容易使用。</p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式：在一个方法中定义一个算法骨架，而将一些步骤延迟到子类中。模板方法使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<h4 id="hook方法"><a href="#hook方法" class="headerlink" title="hook方法"></a>hook方法</h4><p>void hook():是指一种抽象类中可选的方法，你可以选择性的继承它，因此不需要把他设置为抽象方法，避免子类实现麻烦。</p>
<h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p>别调用我们，我们会调用你。</p>
<p>防止“依赖腐败”（环形依赖调用），在此原则下，高层组件会调用低层组件，底层不应该调用高层。</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p><strong>定义</strong>：允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p>
<h2 id="附：UML图解释"><a href="#附：UML图解释" class="headerlink" title="附：UML图解释"></a>附：UML图解释</h2><p>箭头从A指向B，实线+实心箭头：A继承自B</p>
<p>箭头从A指向B，虚线线+实心箭头：实现关系，表现为继承抽象类</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/线程池原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/线程池原理/" itemprop="url">
                  线程池原理解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-06 16:37:30" itemprop="dateCreated datePublished" datetime="2019-01-06T16:37:30+08:00">2019-01-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-06 21:20:30" itemprop="dateModified" datetime="2018-01-06T21:20:30+08:00">2018-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池原理解析"><a href="#线程池原理解析" class="headerlink" title="线程池原理解析"></a>线程池原理解析</h1><p>参考：JAVA线程池原理详解一</p>
<h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><p>线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。<br>可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。</p>
<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,    //线程池核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,//线程池最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,//当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//存放任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span><span class="comment">//超出线程范围和队列容量的任务的处理程序</span></span></span><br></pre></td></tr></table></figure>
<p>corePoolSize：线程池核心线程数量<br>maximumPoolSize:线程池最大线程数量<br>keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间<br>unit：存活时间的单位<br>workQueue：存放任务的队列<br>handler：超出线程范围和队列容量的任务的处理程序</p>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>提交一个任务到线程池中，线程池的处理流程如下：</p>
<ol>
<li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p>线程池容器–&gt;集合(ArrayList,HashSrt,LinkedList<thread>,HashMap)<br>当程序第一次启动的时候，创建多个线程池，保存到一个集合中，当要使用的时候就取出来：<br>Thread t = list.remove(0);//返回的是被移除的元素<br>Thread t  = Linked。removeFist();<br>当使用完毕时归还：<br>list.add(t);<br>linked.addList(t);</thread></p>
<h2 id="线程池使用步骤"><a href="#线程池使用步骤" class="headerlink" title="线程池使用步骤"></a>线程池使用步骤</h2><ol>
<li>使用线程池工厂类Executors中的newFixedThreadPool产生一个指定线程数的线程池</li>
<li>创建一个类，实现Runnable接口，设置线程任务。</li>
<li>调用ExecutorsService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
<li>调用ExecutorsService中的方法shutdown销毁线程池（不建议执行）</li>
</ol>
<p>线程池的源码解读<br>1、ThreadPoolExecutor的execute()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">　　　　　　 <span class="comment">//如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">　　　　　　　　　　<span class="comment">//线程池处于运行状态并且加入队列成功</span></span><br><span class="line">            <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                    ensureQueuedTaskHandled(command);</span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　　　<span class="comment">//线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">　　　　　　　　　　　<span class="comment">//创建线程失败，则采取阻塞处理的方式</span></span><br><span class="line">                reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、创建线程的方法：addIfUnderCorePoolSize(command)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">                t = addThread(firstTask);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过一个程序来观察线程池的工作原理：</p>
<ol>
<li><p>创建一个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolTest implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(300);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池循环运行16个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedBlockingQueue&lt;Runnable&gt; queue =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>);</span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, queue);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threadPool.execute(</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadPoolTest(), <span class="string">"Thread"</span>.concat(i + <span class="string">""</span>)));</span><br><span class="line">            System.out.println(<span class="string">"线程池中活跃的线程数： "</span> + threadPool.getPoolSize());</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"----------------队列中阻塞的线程数"</span> + queue.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程池中活跃的线程数： <span class="number">1</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">2</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">3</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">4</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">1</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">2</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">3</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">4</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">6</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">7</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">8</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">9</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">10</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,<span class="number">5</span>,main] rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">232204</span>a1[Running, pool size = <span class="number">10</span>, active threads = <span class="number">10</span>, queued tasks = <span class="number">5</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2047</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">823</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1369</span>)</span><br><span class="line">    at test.ThreadTest.main(ThreadTest.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure></p>
<p>从结果可以观察出：</p>
<ol>
<li>创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。</li>
<li>我们通过queue.size()的方法来获取工作队列中的任务数。</li>
<li>运行原理：<br>   <strong>刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。当然，为了达到我需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放！！！</strong></li>
</ol>
<h2 id="RejectedExecutionHandler：饱和策略"><a href="#RejectedExecutionHandler：饱和策略" class="headerlink" title="RejectedExecutionHandler：饱和策略"></a>RejectedExecutionHandler：饱和策略</h2><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：</p>
<ol>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用所在的线程运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/模板/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/模板/" itemprop="url">
                  模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 16:37:30" itemprop="dateCreated datePublished" datetime="2019-01-03T16:37:30+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-05 21:20:30" itemprop="dateModified" datetime="2019-01-05T21:20:30+08:00">2019-01-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/模板/" itemprop="url" rel="index"><span itemprop="name">模板</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/Nginx配置简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/Nginx配置简介/" itemprop="url">
                  Nginx配置简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-31 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-31T16:37:30+08:00">2018-12-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-01 21:20:30" itemprop="dateModified" datetime="2019-01-01T21:20:30+08:00">2019-01-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/工具类/" itemprop="url" rel="index"><span itemprop="name">工具类</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h1><h2 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h2><ol>
<li>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理</li>
<li>负载均衡</li>
<li>web缓存</li>
</ol>
<h2 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h2><p><a href="https://www.cnblogs.com/knowledgesea/p/5175711.html" target="_blank" rel="noopener">nginx文件结构</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li>events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li>http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li>server块：配置虚拟主机的相关参数，一个http中可以有多个server。</li>
<li>location块：配置请求的路由，以及各种页面的处理情况。</li>
</ol>
<h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><p><a href="https://www.cnblogs.com/liang-wei/p/5849771.html" target="_blank" rel="noopener">nginx配置文件nginx.conf超详细讲解</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#nginx进程,一般设置为和cpu核数一样</span><br><span class="line">worker_processes 4;                        </span><br><span class="line">#错误日志存放目录 </span><br><span class="line">error_log  /data1/logs/error.log  crit;  </span><br><span class="line">#运行用户，默认即是nginx，可不设置</span><br><span class="line">user nginx       </span><br><span class="line">#进程pid存放位置</span><br><span class="line">pid        /application/nginx/nginx.pid;        </span><br><span class="line"></span><br><span class="line">#Specifies the value for maximum file descriptors that can be opened by this process. </span><br><span class="line">#最大文件打开数（连接），可设置为系统优化后的ulimit -HSn的结果</span><br><span class="line">worker_rlimit_nofile 51200;</span><br><span class="line"></span><br><span class="line">cpu亲和力配置，让不同的进程使用不同的cpu</span><br><span class="line"></span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000 0001 00100100 1000;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">events </span><br><span class="line">&#123;</span><br><span class="line">  use epoll;       #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">  worker_connections 1024;  #;单个后台worker process进程的最大并发链接数</span><br><span class="line">&#125;</span><br><span class="line">###################################################</span><br><span class="line">http </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">include mime.types; #文件扩展名与类型映射表</span><br><span class="line">default_type application/octet-stream; #默认文件类型</span><br><span class="line"></span><br><span class="line">#limit模块，可防范一定量的DDOS攻击</span><br><span class="line">#用来存储session会话的状态，如下是为session分配一个名为one的10M的内存存储区，限制了每秒只接受一个ip的一次请求 1r/s</span><br><span class="line">  limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br><span class="line">  limit_conn_zone $binary_remote_addr zone=addr:10m;</span><br><span class="line">  include       mime.types;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">#第三方模块lua防火墙</span><br><span class="line">    lua_need_request_body on;</span><br><span class="line">    #lua_shared_dict limit 50m;</span><br><span class="line">    lua_package_path &quot;/application/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">    init_by_lua_file &quot;/application/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">    access_by_lua_file &quot;/application/nginx/conf/waf/access.lua&quot;;</span><br><span class="line"></span><br><span class="line"> #设定请求缓存    </span><br><span class="line">  server_names_hash_bucket_size 128;</span><br><span class="line">  client_header_buffer_size 512k;</span><br><span class="line">  large_client_header_buffers 4 512k;</span><br><span class="line">  client_max_body_size 100m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #隐藏响应header和错误通知中的版本号</span><br><span class="line">  server_tokens off;</span><br><span class="line">  #开启高效传输模式   </span><br><span class="line">  sendfile on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #激活tcp_nopush参数可以允许把httpresponse header和文件的开始放在一个文件里发布，</span><br><span class="line">  积极的作用是减少网络报文段的数量</span><br><span class="line">  tcp_nopush     on;</span><br><span class="line">  #激活tcp_nodelay，内核会等待将更多的字节组成一个数据包，从而提高I/O性能</span><br><span class="line">  tcp_nodelay on;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/Linux环境下Mysql5.7的tar包形式安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/Linux环境下Mysql5.7的tar包形式安装/" itemprop="url">
                  Linux环境下Mysql5.7的tar包形式安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 16:37:30 / 修改时间：20:20:30" itemprop="dateCreated datePublished" datetime="2018-12-26T16:37:30+08:00">2018-12-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="Linux环境下Mysql5-7的tar包形式安装"><a href="#Linux环境下Mysql5-7的tar包形式安装" class="headerlink" title="Linux环境下Mysql5.7的tar包形式安装"></a>Linux环境下Mysql5.7的tar包形式安装</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>下载地址<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">Mysql官网</a></li>
<li>选择对应版本：<ol>
<li>系统选择 Red Hat Enterprise Linux / Oracle Linux 系统</li>
<li>版本选择 Oracl Linux 7 (x86, 64-bit) 版本</li>
<li>选择mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar版本下载</li>
</ol>
</li>
<li>上传到服务器<br> 使用相应工具上传到服务器，这里用的是SecureCRT 8.1上传。<br> (1)在服务器界面按快捷键(Alt+P).<br> (2)将文件mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar放到本地的文档目录下<br> (3)输入命令put -r mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar,此时文件会传输到root根目录，当然你也可以自己指定目录</li>
<li>将文件解压到指定目录，现在我们用的是/usr/local/mysql5.7</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>卸载centos7中自带的mariadb<br><code>rpm -qa|grep mariadb</code> //查询出来已安装的mariadb<br><code>rpm -e --nodeps</code> 文件名 //卸载mariadb,文件名为上述命令查询出来的文件</li>
<li><p>查看是否已经安装了mysql(新机器可以跳过)</p>
<p> <code>rpm -qa | grep -i mysql</code></p>
<p> 查找mysql文件<code>find / -name mysql</code></p>
<p> 使用<code>rm -rf mysql</code>文件路径删除</p>
<p> 删除分散mysql文件<code>find / -name mysql / # whereis mysql</code></p>
<p> 删除配置文档<code>rm -rf /etc/my.cnf</code></p>
<p> 再次查找机器是否安装mysql<code>rpm -qa|grep -i mysql</code></p>
</li>
<li><p>解压文件<br>tar -xvf mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar</p>
</li>
<li><p>创建相应用户组（可忽略）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#检查mysql是否存在      </span><br><span class="line">[root@hdp265dnsnfs ~]# rpm -qa | grep mysql     </span><br><span class="line">[root@hdp265dnsnfs ~]#      </span><br><span class="line"></span><br><span class="line">#检查mysql组和用户是否存在，如无创建    </span><br><span class="line">[root@hdp265dnsnfs ~]# cat /etc/group | grep mysql  </span><br><span class="line">[root@hdp265dnsnfs ~]#  cat /etc/passwd | grep mysql    </span><br><span class="line"></span><br><span class="line">#创建mysql用户组    </span><br><span class="line">[root@hdp265dnsnfs ~]# groupadd mysql   </span><br><span class="line">#创建一个用户名为mysql的用户并加入mysql用户组   </span><br><span class="line">[root@hdp265dnsnfs ~]# useradd -g mysql mysql   </span><br><span class="line">#制定password 为111111  </span><br><span class="line">[root@hdp265dnsnfs ~]# passwd mysql </span><br><span class="line">Changing password for user mysql.   </span><br><span class="line">New password:   </span><br><span class="line">BAD PASSWORD: The password is a palindrome  </span><br><span class="line">Retype new password:    </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
</li>
<li><p>写配置文件/etc/my.cnf<br> 命令：<code>touch my.cnf</code> 创建文件<br> 命令：<code>mkdir data</code> 创建文件夹<br> 命令：<code>vi my.cnf</code> 编辑文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysql] </span><br><span class="line">#设置mysql客户端默认字符集  </span><br><span class="line">default-character-set=utf8      </span><br><span class="line">[mysqld]    </span><br><span class="line">#设置3306端口   </span><br><span class="line">port = 3306     </span><br><span class="line">#设置mysql的安装目录    </span><br><span class="line">basedir=/var/mysql5.7    </span><br><span class="line">#设置mysql数据库的数据的存放目录    </span><br><span class="line">datadir=/var/mysql5.7/data   </span><br><span class="line">#允许最大连接数     </span><br><span class="line">max_connections=200     </span><br><span class="line">#服务端使用的字符集默认为8比特编码的latin1字符集    </span><br><span class="line">character-set-server=utf8   </span><br><span class="line">#创建新表时将使用的默认存储引擎     </span><br><span class="line">lower_case_table_names=1    </span><br><span class="line">max_allowed_packet=16M</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量<br>命令：<code>vi .bashrc</code> 打开配置文件<br>输入export PATH=$PATH:/usr/local/mysql5.7</p>
</li>
<li><p>初始化<br><code>/usr/local/mysql5.7/bin/mysqld --initialize-insecure --user=mysql</code></p>
</li>
<li><p>启动<br>命令：<code>/usr/local/mysql5.7/bin/mysqld_safe &amp;</code>启动<br>接着设置root的密码</p>
</li>
<li><p>检查是否成功<br>命令：<code>ps -ef |grep mysql</code> 检查进程<br>命令: <code>netstat -an |grep 3306</code>  检查默认端口</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/第96阶：Redis/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/第96阶：Redis/" itemprop="url">
                  第96阶：Redis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-22 16:37:30 / 修改时间：21:20:30" itemprop="dateCreated datePublished" datetime="2018-12-22T16:37:30+08:00">2018-12-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第96阶：Redis"><a href="#第96阶：Redis" class="headerlink" title="第96阶：Redis"></a>第96阶：Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有字符串，链表，集合和有序集合。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种排序功能。</p>
<p>Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 </p>
<p>redis提供两种方式进行持久化，一种是<strong>RDB持久化</strong>（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是<strong>AOF（append only file）持久化</strong>（原理是将Reids的操作日志以追加的方式写入文件）。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">redis持久化的几种方式</a></p>
<h3 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h3><ol>
<li>RDB持久化<br> RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png" alt="RDB持久化原理图"></li>
<li>AOF持久化<br> AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。<br><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161604968-371688235.png" alt="AOF持久化"></li>
</ol>
<h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p>RDB存在哪些优势呢？     </p>
<ol>
<li><p>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p>
</li>
<li><p>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</p>
</li>
<li><p>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
</li>
<li><p>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
</li>
</ol>
<p>RDB又存在哪些劣势呢？</p>
<ol>
<li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
</li>
<li><p>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
</li>
</ol>
<h2 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h2><p><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis常用指菜鸟教程</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/第62阶：jvm虚拟机优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/第62阶：jvm虚拟机优化/" itemprop="url">
                  第62阶：jvm虚拟机优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-14 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-14T16:37:30+08:00">2018-12-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-18 21:20:30" itemprop="dateModified" datetime="2018-12-18T21:20:30+08:00">2018-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第62阶：jvm虚拟机优化"><a href="#第62阶：jvm虚拟机优化" class="headerlink" title="第62阶：jvm虚拟机优化"></a>第62阶：jvm虚拟机优化</h1><p><a href="https://www.bilibili.com/video/av31834249/?spm_id_from=333.788.videocard.17" target="_blank" rel="noopener">jvm虚拟机优化</a></p>
<h2 id="虚拟机桥接模式和NAT"><a href="#虚拟机桥接模式和NAT" class="headerlink" title="虚拟机桥接模式和NAT"></a>虚拟机桥接模式和NAT</h2><p>在桥接模式下。VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它能够訪问网内不论什么一台机器。你须要手工为虚拟系统配置IP地址、子网掩码，并且还要和宿主机器处于同一网段，这样虚拟系统才干和宿主机器进行通信。</p>
<p>使用NAT模式。就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来訪问公网。使用NAT模式能够实如今虚拟系统里訪问互联网。</p>
<p>注意：NAT模式和桥接模式不能相互连接</p>
<h2 id="java虚拟机的基本结构"><a href="#java虚拟机的基本结构" class="headerlink" title="java虚拟机的基本结构"></a>java虚拟机的基本结构</h2><p><a href="https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png" target="_blank" rel="noopener">JVM的基本结构及其各部分详解（一）</a></p>
<p><img src="https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png" alt="java虚拟机的基本结构"></p>
<ol>
<li><p>类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</p>
</li>
<li><p>java堆在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的，这是一块与java应用密切相关的内存空间。</p>
</li>
<li><p>java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>垃圾回收系统是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理。</p>
</li>
<li><p>每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧信息，java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切相关。</p>
</li>
<li><p>本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用C编写）</p>
</li>
<li><p>PC（Program Counter）寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined</p>
</li>
<li><p>执行引擎是java虚拟机的最核心组件之一，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。 </p>
</li>
</ol>
<h2 id="jvm虚拟机参数"><a href="#jvm虚拟机参数" class="headerlink" title="jvm虚拟机参数"></a>jvm虚拟机参数</h2><p><a href="https://blog.csdn.net/momo_ibeike/article/details/76370428" target="_blank" rel="noopener">常用Java虚拟机调试和配置参数</a></p>
<ol>
<li><strong>-XX</strong>：对于系统级别的（jvm）配置，如配置日志信息、配置JVM使用什么样的垃圾回收器。</li>
<li><strong>非-XX</strong>：的基本上是应用层面上的配置。</li>
<li><strong>+</strong>：启用</li>
<li><strong>-</strong>：禁用</li>
<li><strong>-Xmn2g</strong>：设置年轻代(Eden)大小。</li>
<li>输入内存溢出信息、设置内存溢出路径。</li>
<li><strong>-Xss</strong>：线程最大栈空间，</li>
<li><strong>-XX:PermSize，-XX:PermSize=MaxPermSize</strong>：方法区大小。</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
</ol>
<p>基本策略：可以设置新生代的大小、新生代和老年代的比例。尽量将对象预留在新生代，减少老年代GC次数。</p>
<h2 id="负载均衡和反向代理"><a href="#负载均衡和反向代理" class="headerlink" title="负载均衡和反向代理"></a>负载均衡和反向代理</h2><p><strong>负载均衡</strong>（Load Balance）<br>其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>常见的负载均衡服务器有：<code>F5</code>,<code>LVS</code></p>
<p><strong>反向代理</strong>（Reverse Proxy）<br>是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>常见的反向代理服务器有:<code>nginx</code>,<code>haproxy</code></p>
<h2 id="GC清除对象"><a href="#GC清除对象" class="headerlink" title="GC清除对象"></a>GC清除对象</h2><p>当connection=null时，GC并没有立即回收对象，什么时候回收并不知道。除非手动调用GC回收方法。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><a href="https://www.cnblogs.com/huajiezh/p/5769255.html" target="_blank" rel="noopener">深入理解java垃圾回收算法</a></p>
<ol>
<li>引用计数算法<br> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。<strong>缺点</strong>：相互循环引用会出现问题</li>
<li>标记-清除算法<br> 最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。<strong>缺点</strong>：首先，效率问题，标记和清除<strong>效率都不高</strong>。其次，标记清除之后会产生大量的<strong>不连续的内存碎片</strong>，空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
<li>复制算法<br> 目前用于新生代，将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<strong>缺点</strong>：可使用的内存降为原来一半。</li>
<li>标记压缩算法<br> 目前用于老年代</li>
</ol>
<h2 id="TLAB区域"><a href="#TLAB区域" class="headerlink" title="TLAB区域"></a>TLAB区域</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/第09阶：多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/第09阶：多线程/" itemprop="url">
                  2018第09阶：多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-08T16:37:30+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-23 21:20:30" itemprop="dateModified" datetime="2018-12-23T21:20:30+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第09阶：多线程"><a href="#第09阶：多线程" class="headerlink" title="第09阶：多线程"></a>第09阶：多线程</h1><h2 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h2><p><a href="https://www.bilibili.com/video/av31434494/?p=3" target="_blank" rel="noopener">2018百战程序员JAVA全系列终结版第09阶：多线程</a></p>
<h2 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run()和start()的区别"></a>run()和start()的区别</h2><ol>
<li>start：<br>　　用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。      </li>
<li>run：<br>　　run()方法只是类的一个普通方法而已，如果直接调用Run方法，<strong>程序中依然只有主线程这一个线程，其程序执行路径还是只有一条</strong>，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</li>
</ol>
<h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>如果一个对象只是用一次，可以使用匿名。</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实现类对象</span></span><br><span class="line">StartRun st = <span class="keyword">new</span> StartRun();</span><br><span class="line"><span class="comment">//创建代理类</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(sr);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></p>
<p>可以简化为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> StartRun()).start();</span><br></pre></td></tr></table></figure></p>
<h2 id="Thread类、Runnable接和Callable接口"><a href="#Thread类、Runnable接和Callable接口" class="headerlink" title="Thread类、Runnable接和Callable接口"></a>Thread类、Runnable接和Callable接口</h2><p>推荐使用Runnable接口，好处是：</p>
<ol>
<li>接口可以实现多个，突破单继承。</li>
<li><p>便于共享资源。因为一个线程只能启动一次，通过Thread实现线程时，线程和线程所要执行的任务是捆绑在一起的。而一个任务可以启动多个线程，通过Runnable方式实现的线程，实际是开辟一个线程，将任务传递进去，由此线程执行。</p>
</li>
<li><p>Callable接口<br>Callable接口用于juc并发编程</p>
</li>
</ol>
<ul>
<li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li>
<li>call()方法可抛出异常，而run()方法是不能抛出异常的。</li>
<li>运行Callable任务可拿到一个Future对象。</li>
</ul>
<p>Future<br>    Callable任务返回Future对象。即：Callable和Future一个产生结果，一个拿到结果。Future 表示异步计算的结果。</p>
<p><a href="https://www.cnblogs.com/felixzh/p/6044371.html" target="_blank" rel="noopener">Callable接口、Runable接口、Future接口</a></p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda推导必须存在类型</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程只为用户线程服务，JVM不用等待守护线程结束才结束。而JVM默认会等用户线程结束才会结束。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>同步方法与同步块的区别：</p>
<p>1.同步方法<br>同步方法锁定的是this对象，不是方法。<br>即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。代码如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.同步代码块<br>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。代码如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 </p>
<h2 id="选区加锁对象"><a href="#选区加锁对象" class="headerlink" title="选区加锁对象"></a>选区加锁对象</h2><p>加锁的时候应该加在大对象上，防止调用对象不是同一个。</p>
<h2 id="Quartz使用"><a href="#Quartz使用" class="headerlink" title="Quartz使用"></a>Quartz使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建Scheduler工厂</span></span><br><span class="line">SchedulerFactory sf = <span class="keyword">new</span> SchedulerFactory();</span><br><span class="line"><span class="comment">//2. 从工厂中获取调度器</span></span><br><span class="line">Scheduler sched = sf.getScheduler();</span><br><span class="line"><span class="comment">//3. 创建JobDetail</span></span><br><span class="line">JobDetail job = newJob(HelloJob.class).withIdentify(<span class="string">"job1"</span>,<span class="string">"group1"</span>).build();</span><br><span class="line"><span class="comment">//时间</span></span><br><span class="line">Date runTime = evenSecondDateAfterNow();</span><br><span class="line"><span class="comment">//4. 触发条件</span></span><br><span class="line">Trigger trigger = newTrigger().withIdentify(<span class="string">"trigger1"</span>,<span class="string">"group1"</span>).start(runTime).build();</span><br><span class="line"><span class="comment">//5. 注册任务</span></span><br><span class="line">sched.schedulerJob(job,trigger);</span><br><span class="line"><span class="comment">//6. 启动</span></span><br><span class="line">sched.start</span><br></pre></td></tr></table></figure>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>只保证数据同步，当数据修改时立即通知其他持有者更新数据。比synchronized开销小，但不保证操作的原子性。已经很少使用了。</p>
<h2 id="使用double-checking和volatile进行单例设计"><a href="#使用double-checking和volatile进行单例设计" class="headerlink" title="使用double-checking和volatile进行单例设计"></a>使用double-checking和volatile进行单例设计</h2><p>单例模式：套路，在多线程环境下，对外存在一个对象。<br>在懒汉式基础上修改。</p>
<ol>
<li>构造器私有化，防止外部创建</li>
<li>提供私有的静态属性</li>
<li>提供公共的静态方法<br>静态方法示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLocking <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//再次检测，减少不必要的同步。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> !== instance)&#123;<span class="keyword">return</span> instance&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> DoubleCheckedLocking();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">&#125;instance</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ThreadLoacl"><a href="#ThreadLoacl" class="headerlink" title="ThreadLoacl"></a>ThreadLoacl</h2><p>ThreadLoacl：分析上下文、环境、起点。    </p>
<ol>
<li>构造器：哪里调用就属于哪里，找线程体。</li>
<li>run方法：线程本身的。<br>InheritableThreadLoacl：继承上下文，环境的数据，拷贝一份给线程，起点</li>
</ol>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>原理：锁添加计数器，当加锁对象被访问时，判断是否锁定且为当前持有锁对象，否则wait();，是则计数器加1，当计数器为0时说明对象释放锁。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>独占锁，会导致其他线程挂起。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>没有锁，失败重试，直到成功。<br>乐观锁实现方式：Compare and Swap 比较并交换。<br>需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/Effective-Java-3rd第12章(85~90)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/Effective-Java-3rd第12章(85~90)/" itemprop="url">
                  Effective Java 3rd 第12章 序列化(85~90)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-07T16:37:30+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:51:00" itemprop="dateModified" datetime="2019-01-06T21:51:00+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="第12章-序列化"><a href="#第12章-序列化" class="headerlink" title="第12章 序列化"></a>第12章 序列化</h2><h2 id="第85条-尽量不要使用Serializable"><a href="#第85条-尽量不要使用Serializable" class="headerlink" title="第85条 尽量不要使用Serializable"></a>第85条 尽量不要使用Serializable</h2><p>序列化的一个基本问题是它的攻击面太大而无法保护，在对字节流进行反序列化的过程中，该方法可以执行来自这些类型的任何代码。不可信流的反序列化可能导致远程代码执行(RCE)、拒绝服务(DoS)和一系列其他利用。这些方法称为gadget。多个小工具可以协同使用，形成一个小工具链。有时会发现一个小工具链，它足够强大，允许攻击者在底层硬件上执行任意本机代码，只给攻击者提交精心设计的字节流进行反序列化的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deserialization bomb - deserializing this stream takes forever</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] bomb() &#123;</span><br><span class="line">    Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; s1 = root;</span><br><span class="line">    Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        t1.add(<span class="string">"foo"</span>); <span class="comment">// Make t1 unequal to t2</span></span><br><span class="line">        s1.add(t1); s1.add(t2);</span><br><span class="line">        s2.add(t1); s2.add(t2);</span><br><span class="line">        s1 = t1;</span><br><span class="line">        s2 = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialize(root); <span class="comment">// Method omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象图由201个HashSet实例组成，每个实例包含3个或更少的对象引用。整个流的长度为5744字节，但是在反序列化之前sun就已经耗尽了。问题是反序列化哈希集实例需要计算其元素的哈希码。root哈希集的2个元素本身就是包含2个哈希集元素的哈希集，每个哈希集元素包含2个哈希集元素，依此类推，深度为100层。因此，反序列化集合会导致hashCode方法被调用超过2100次。除了反序列化要花费很长时间之外，反序列化器没有任何出错的迹象。生成的对象很少，堆栈深度是有限的。</p>
<p>避免序列化被利用的最佳方法是永远不要反序列化任何东西。没有理由在您编写的任何新系统中使用Java序列化。</p>
<p>有许多其他的跨平台序列化方法，最常用的是以下两个：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>Json</th>
<th>protobuf</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>基于文本的</td>
<td>基于二进制的</td>
</tr>
<tr>
<td>优点</td>
<td>可读性好</td>
<td>高效</td>
</tr>
<tr>
<td>用途</td>
<td>完全是一种数据表示</td>
<td>提供模式(类型)来记录和强制适当的使用</td>
</tr>
<tr>
<td>备注</td>
<td>对于基于文本的表示非常有效</td>
<td>提供了一种可供选择的文本表示，以便在需要人类可读性的地方使用(pbtxt)</td>
</tr>
</tbody>
</table>
<p>总之，序列化是危险的，应该避免。如果您从头开始设计系统，那么可以使用跨平台的结构化数据表示，例如JSON或protobuf。不要反序列化不可信的数据。如果必须这样做，请使用对象反序列化筛选，但要注意，它不能保证阻止所有攻击。避免编写可序列化的类。如果你必须这样做，一定要非常小心。</p>
<h2 id="第86条-非常谨慎地实现可序列化"><a href="#第86条-非常谨慎地实现可序列化" class="headerlink" title="第86条 非常谨慎地实现可序列化"></a>第86条 非常谨慎地实现可序列化</h2><p>虽然使一个类可被序列化的直接开销非常低，甚至可以忽略不计，但是为了序列化而付出的长期开销往往是实实在在的。实现Serializable 接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。如果你接受了默认的序列化形式，这个类中私有的和包级私有的实例域将都变成导出的API的一部分，这不符合“最低限度地访问域”的实践准则（见第15条），从而它就失去了作为信息隐藏工具的有效性。</p>
<ol>
<li><strong>序列化会使类的演变受到限制</strong>，这种限制的一个例子与流的唯一标识符(stream unique identifier)有关，通常它也被称为序列版本UID (serial version UID )</li>
<li><strong>实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性(第85条)</strong>。无论你是接受了默认的行为，还是覆盖了默认的行为，反序列化机制(deserialization)都是一个“隐藏的构造器”，具备与其他构造器相同的特点。因为反序列化机制中没有显式的构造器，所以你很容易忘记要确保：反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，井且不允许攻击者访问正在构造过程中的对象的内部信息。依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受到非法访问（见第88条）。</li>
<li><strong>实现Serializable的第三个成本是，它增加了与发布类的新版本相关联的测试负担</strong>。当一个可序列化的类被修订的时候，要检查是否可以在新版本中序列化一个实例，然后在旧版本中反序列化。</li>
<li><strong>为继承而设计的类(项目19)很少实现可序列化，接口也很少扩展它</strong>。</li>
<li><strong>内部类(项目24)不应该实现可序列化</strong>。它们使用编译器生成的合成字段存储对封闭实例的引用，并存储来自封闭范围的局部变量值。这些字段如何与类定义对应是未指定的，匿名类和本地类的名称也是未指定的。因此，内部类的默认序列化形式是未定义的。然而，静态成员类可以实现序列化。</li>
</ol>
<p>如果一个类将要加入到某个框架中，井且该框架依赖于序列化来实现对象传输或者持久化，对干这个类来说，实现SeriaJizable接口就非常有必要。</p>
<p>总而言之，实现Serializable的易用性是似是而非的。除非类只在受保护的环境中使用，在这种环境中版本永远不必互操作，服务器永远不会暴露于不受信任的数据，否则实现Serializable是一个需要非常小心的严肃承诺。如果类允许继承，则需要格外小心。</p>
<h2 id="第87条-考虑使用自定义的序列化形式"><a href="#第87条-考虑使用自定义的序列化形式" class="headerlink" title="第87条 考虑使用自定义的序列化形式"></a>第87条 考虑使用自定义的序列化形式</h2><p>如果没有先认真考虑默认的序列化形式是否合达，则不要贸然接受。</p>
<p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。使用默认序列化形式会有以下4个缺点：</p>
<ol>
<li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li>
<li>它会消耗过多的空间</li>
<li>它会消耗过多的时间。</li>
<li>它会引起栈溢出。</li>
</ol>
<p>论你是否使用默认的序列化形式，当defaultWriteObject方法被调用的时候，每一个未被标记为transient的实例域都会被序列化。因此，每一个可以被标记为transient的实例域都应该做上这样的标记。在决定将一个域做成非transient 的乏前，请一定要确信它的值将是该对象逻辑状态的一部分。当一个实例被反序列化的时候，这些域将被初始化为它们的默认值(default value)：对于对象引用域，默认值为null,对于数值基本域，默认值为o,对于boolean域，默认值为false</p>
<p>总而言之，当你决定要将一个类做成可序列化的时候（见第86条），讲仔细考虑应该采用什么样的序列化形式。只有当默认的序列化形式能够合理地描述对象的逻辑状态时，才能使用默认的序列化形式；否则就要设计一个自定义的序列化形式，通过它合理地描述对象的状态。你应该分配足够多的时间来设计类的序列化形式，就好像分配足够多的时间来设计它的导出方法一样（见第51条）。正如你无法在将来的版本中去掉导出方法一样，你也不能去掉序列化形式中的域；它们必须被永久地保留下去，以确保序列化兼容性。选择错误的序列化形式对干一个类的复杂性和性能都会有永久的负面影响。</p>
<h2 id="第88条-保护性地编写readObjct方法"><a href="#第88条-保护性地编写readObjct方法" class="headerlink" title="第88条 保护性地编写readObjct方法"></a>第88条 保护性地编写readObjct方法</h2><p>构造器必须检查其参数的有效性（见第38条），并且在必要的时候对参数进行保护性拷贝（见第39条）。</p>
<p>总而言之，每当你编写readObject方法的时候，都要这样想：你正在编写一个公有的构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例。不要假设这个字节流一定代表着一个真正被序列化过的实例。虽然在本条目的例子中，类使用了默认的序列化形式，但是，所有讨论到的有可能发生的问题也同样适用千使用自定义序列化形式的类。下面以摘要的形式给出一些指导方针，有助千编写出更加健壮的readObject方法：</p>
<ul>
<li>对于对象引用埮必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属千这一类别。</li>
<li>对干任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li>
<li>如果整个对象图在被反序列化之后必须进行验证，就应该使用Objectlnput Validation接口[JavaSE6, Serialization]。</li>
<li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li>
</ul>
<h2 id="第89条-若想控制实例，使用Enum比readResolve"><a href="#第89条-若想控制实例，使用Enum比readResolve" class="headerlink" title="第89条 若想控制实例，使用Enum比readResolve"></a>第89条 若想控制实例，使用Enum比readResolve</h2><p>总而言之，你应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控(instance-co?trolled)的类，就必须提供一个readResolver方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p>
<h2 id="第90条-考虑用序列化代理代替序列化实例"><a href="#第90条-考虑用序列化代理代替序列化实例" class="headerlink" title="第90条 考虑用序列化代理代替序列化实例"></a>第90条 考虑用序列化代理代替序列化实例</h2><p>总而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">小华</p>
              <p class="site-description motion-element" itemprop="description">个人学习博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小华</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
