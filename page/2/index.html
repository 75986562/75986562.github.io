<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="萌面超人">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="萌面超人">
<meta property="og:description" content="个人学习博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="萌面超人">
<meta name="twitter:description" content="个人学习博客">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>萌面超人</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萌面超人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">
    <a href="/404/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/Linux环境下Mysql5.7的tar包形式安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/Linux环境下Mysql5.7的tar包形式安装/" itemprop="url">
                  Linux环境下Mysql5.7的tar包形式安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 16:37:30 / 修改时间：20:20:30" itemprop="dateCreated datePublished" datetime="2018-12-26T16:37:30+08:00">2018-12-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="Linux环境下Mysql5-7的tar包形式安装"><a href="#Linux环境下Mysql5-7的tar包形式安装" class="headerlink" title="Linux环境下Mysql5.7的tar包形式安装"></a>Linux环境下Mysql5.7的tar包形式安装</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>下载地址<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">Mysql官网</a></li>
<li>选择对应版本：<ol>
<li>系统选择 Red Hat Enterprise Linux / Oracle Linux 系统</li>
<li>版本选择 Oracl Linux 7 (x86, 64-bit) 版本</li>
<li>选择mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar版本下载</li>
</ol>
</li>
<li>上传到服务器<br> 使用相应工具上传到服务器，这里用的是SecureCRT 8.1上传。<br> (1)在服务器界面按快捷键(Alt+P).<br> (2)将文件mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar放到本地的文档目录下<br> (3)输入命令put -r mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar,此时文件会传输到root根目录，当然你也可以自己指定目录</li>
<li>将文件解压到指定目录，现在我们用的是/usr/local/mysql5.7</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>卸载centos7中自带的mariadb<br><code>rpm -qa|grep mariadb</code> //查询出来已安装的mariadb<br><code>rpm -e --nodeps</code> 文件名 //卸载mariadb,文件名为上述命令查询出来的文件</li>
<li><p>查看是否已经安装了mysql(新机器可以跳过)</p>
<p> <code>rpm -qa | grep -i mysql</code></p>
<p> 查找mysql文件<code>find / -name mysql</code></p>
<p> 使用<code>rm -rf mysql</code>文件路径删除</p>
<p> 删除分散mysql文件<code>find / -name mysql / # whereis mysql</code></p>
<p> 删除配置文档<code>rm -rf /etc/my.cnf</code></p>
<p> 再次查找机器是否安装mysql<code>rpm -qa|grep -i mysql</code></p>
</li>
<li><p>解压文件<br>tar -xvf mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar</p>
</li>
<li><p>创建相应用户组（可忽略）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#检查mysql是否存在      </span><br><span class="line">[root@hdp265dnsnfs ~]# rpm -qa | grep mysql     </span><br><span class="line">[root@hdp265dnsnfs ~]#      </span><br><span class="line"></span><br><span class="line">#检查mysql组和用户是否存在，如无创建    </span><br><span class="line">[root@hdp265dnsnfs ~]# cat /etc/group | grep mysql  </span><br><span class="line">[root@hdp265dnsnfs ~]#  cat /etc/passwd | grep mysql    </span><br><span class="line"></span><br><span class="line">#创建mysql用户组    </span><br><span class="line">[root@hdp265dnsnfs ~]# groupadd mysql   </span><br><span class="line">#创建一个用户名为mysql的用户并加入mysql用户组   </span><br><span class="line">[root@hdp265dnsnfs ~]# useradd -g mysql mysql   </span><br><span class="line">#制定password 为111111  </span><br><span class="line">[root@hdp265dnsnfs ~]# passwd mysql </span><br><span class="line">Changing password for user mysql.   </span><br><span class="line">New password:   </span><br><span class="line">BAD PASSWORD: The password is a palindrome  </span><br><span class="line">Retype new password:    </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
</li>
<li><p>写配置文件/etc/my.cnf<br> 命令：<code>touch my.cnf</code> 创建文件<br> 命令：<code>mkdir data</code> 创建文件夹<br> 命令：<code>vi my.cnf</code> 编辑文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysql] </span><br><span class="line">#设置mysql客户端默认字符集  </span><br><span class="line">default-character-set=utf8      </span><br><span class="line">[mysqld]    </span><br><span class="line">#设置3306端口   </span><br><span class="line">port = 3306     </span><br><span class="line">#设置mysql的安装目录    </span><br><span class="line">basedir=/var/mysql5.7    </span><br><span class="line">#设置mysql数据库的数据的存放目录    </span><br><span class="line">datadir=/var/mysql5.7/data   </span><br><span class="line">#允许最大连接数     </span><br><span class="line">max_connections=200     </span><br><span class="line">#服务端使用的字符集默认为8比特编码的latin1字符集    </span><br><span class="line">character-set-server=utf8   </span><br><span class="line">#创建新表时将使用的默认存储引擎     </span><br><span class="line">lower_case_table_names=1    </span><br><span class="line">max_allowed_packet=16M</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量<br>命令：<code>vi .bashrc</code> 打开配置文件<br>输入export PATH=$PATH:/usr/local/mysql5.7</p>
</li>
<li><p>初始化<br><code>/usr/local/mysql5.7/bin/mysqld --initialize-insecure --user=mysql</code></p>
</li>
<li><p>启动<br>命令：<code>/usr/local/mysql5.7/bin/mysqld_safe &amp;</code>启动<br>接着设置root的密码</p>
</li>
<li><p>检查是否成功<br>命令：<code>ps -ef |grep mysql</code> 检查进程<br>命令: <code>netstat -an |grep 3306</code>  检查默认端口</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/第96阶：Redis/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/第96阶：Redis/" itemprop="url">
                  第96阶：Redis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-22 16:37:30 / 修改时间：21:20:30" itemprop="dateCreated datePublished" datetime="2018-12-22T16:37:30+08:00">2018-12-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第96阶：Redis"><a href="#第96阶：Redis" class="headerlink" title="第96阶：Redis"></a>第96阶：Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有字符串，链表，集合和有序集合。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种排序功能。</p>
<p>Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 </p>
<p>redis提供两种方式进行持久化，一种是<strong>RDB持久化</strong>（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是<strong>AOF（append only file）持久化</strong>（原理是将Reids的操作日志以追加的方式写入文件）。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">redis持久化的几种方式</a></p>
<h3 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h3><ol>
<li>RDB持久化<br> RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png" alt="RDB持久化原理图"></li>
<li>AOF持久化<br> AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。<br><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161604968-371688235.png" alt="AOF持久化"></li>
</ol>
<h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p>RDB存在哪些优势呢？     </p>
<ol>
<li><p>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p>
</li>
<li><p>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</p>
</li>
<li><p>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
</li>
<li><p>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
</li>
</ol>
<p>RDB又存在哪些劣势呢？</p>
<ol>
<li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
</li>
<li><p>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
</li>
</ol>
<h2 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h2><p><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis常用指菜鸟教程</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/第62阶：jvm虚拟机优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/第62阶：jvm虚拟机优化/" itemprop="url">
                  第62阶：jvm虚拟机优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-14 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-14T16:37:30+08:00">2018-12-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-18 21:20:30" itemprop="dateModified" datetime="2018-12-18T21:20:30+08:00">2018-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第62阶：jvm虚拟机优化"><a href="#第62阶：jvm虚拟机优化" class="headerlink" title="第62阶：jvm虚拟机优化"></a>第62阶：jvm虚拟机优化</h1><p><a href="https://www.bilibili.com/video/av31834249/?spm_id_from=333.788.videocard.17" target="_blank" rel="noopener">jvm虚拟机优化</a></p>
<h2 id="虚拟机桥接模式和NAT"><a href="#虚拟机桥接模式和NAT" class="headerlink" title="虚拟机桥接模式和NAT"></a>虚拟机桥接模式和NAT</h2><p>在桥接模式下。VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它能够訪问网内不论什么一台机器。你须要手工为虚拟系统配置IP地址、子网掩码，并且还要和宿主机器处于同一网段，这样虚拟系统才干和宿主机器进行通信。</p>
<p>使用NAT模式。就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来訪问公网。使用NAT模式能够实如今虚拟系统里訪问互联网。</p>
<p>注意：NAT模式和桥接模式不能相互连接</p>
<h2 id="java虚拟机的基本结构"><a href="#java虚拟机的基本结构" class="headerlink" title="java虚拟机的基本结构"></a>java虚拟机的基本结构</h2><p><a href="https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png" target="_blank" rel="noopener">JVM的基本结构及其各部分详解（一）</a></p>
<p><img src="https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png" alt="java虚拟机的基本结构"></p>
<ol>
<li><p>类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</p>
</li>
<li><p>java堆在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的，这是一块与java应用密切相关的内存空间。</p>
</li>
<li><p>java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>垃圾回收系统是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理。</p>
</li>
<li><p>每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧信息，java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切相关。</p>
</li>
<li><p>本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用C编写）</p>
</li>
<li><p>PC（Program Counter）寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined</p>
</li>
<li><p>执行引擎是java虚拟机的最核心组件之一，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。 </p>
</li>
</ol>
<h2 id="jvm虚拟机参数"><a href="#jvm虚拟机参数" class="headerlink" title="jvm虚拟机参数"></a>jvm虚拟机参数</h2><p><a href="https://blog.csdn.net/momo_ibeike/article/details/76370428" target="_blank" rel="noopener">常用Java虚拟机调试和配置参数</a></p>
<ol>
<li><strong>-XX</strong>：对于系统级别的（jvm）配置，如配置日志信息、配置JVM使用什么样的垃圾回收器。</li>
<li><strong>非-XX</strong>：的基本上是应用层面上的配置。</li>
<li><strong>+</strong>：启用</li>
<li><strong>-</strong>：禁用</li>
<li><strong>-Xmn2g</strong>：设置年轻代(Eden)大小。</li>
<li>输入内存溢出信息、设置内存溢出路径。</li>
<li><strong>-Xss</strong>：线程最大栈空间，</li>
<li><strong>-XX:PermSize，-XX:PermSize=MaxPermSize</strong>：方法区大小。</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
</ol>
<p>基本策略：可以设置新生代的大小、新生代和老年代的比例。尽量将对象预留在新生代，减少老年代GC次数。</p>
<h2 id="负载均衡和反向代理"><a href="#负载均衡和反向代理" class="headerlink" title="负载均衡和反向代理"></a>负载均衡和反向代理</h2><p><strong>负载均衡</strong>（Load Balance）<br>其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>常见的负载均衡服务器有：<code>F5</code>,<code>LVS</code></p>
<p><strong>反向代理</strong>（Reverse Proxy）<br>是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>常见的反向代理服务器有:<code>nginx</code>,<code>haproxy</code></p>
<h2 id="GC清除对象"><a href="#GC清除对象" class="headerlink" title="GC清除对象"></a>GC清除对象</h2><p>当connection=null时，GC并没有立即回收对象，什么时候回收并不知道。除非手动调用GC回收方法。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><a href="https://www.cnblogs.com/huajiezh/p/5769255.html" target="_blank" rel="noopener">深入理解java垃圾回收算法</a></p>
<ol>
<li>引用计数算法<br> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。<strong>缺点</strong>：相互循环引用会出现问题</li>
<li>标记-清除算法<br> 最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。<strong>缺点</strong>：首先，效率问题，标记和清除<strong>效率都不高</strong>。其次，标记清除之后会产生大量的<strong>不连续的内存碎片</strong>，空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
<li>复制算法<br> 目前用于新生代，将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<strong>缺点</strong>：可使用的内存降为原来一半。</li>
<li>标记压缩算法<br> 目前用于老年代</li>
</ol>
<h2 id="TLAB区域"><a href="#TLAB区域" class="headerlink" title="TLAB区域"></a>TLAB区域</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/第09阶：多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/第09阶：多线程/" itemprop="url">
                  2018第09阶：多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-08T16:37:30+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-23 21:20:30" itemprop="dateModified" datetime="2018-12-23T21:20:30+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第09阶：多线程"><a href="#第09阶：多线程" class="headerlink" title="第09阶：多线程"></a>第09阶：多线程</h1><h2 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h2><p><a href="https://www.bilibili.com/video/av31434494/?p=3" target="_blank" rel="noopener">2018百战程序员JAVA全系列终结版第09阶：多线程</a></p>
<h2 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run()和start()的区别"></a>run()和start()的区别</h2><ol>
<li>start：<br>　　用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。      </li>
<li>run：<br>　　run()方法只是类的一个普通方法而已，如果直接调用Run方法，<strong>程序中依然只有主线程这一个线程，其程序执行路径还是只有一条</strong>，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</li>
</ol>
<h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>如果一个对象只是用一次，可以使用匿名。</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实现类对象</span></span><br><span class="line">StartRun st = <span class="keyword">new</span> StartRun();</span><br><span class="line"><span class="comment">//创建代理类</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(sr);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></p>
<p>可以简化为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> StartRun()).start();</span><br></pre></td></tr></table></figure></p>
<h2 id="Thread类、Runnable接和Callable接口"><a href="#Thread类、Runnable接和Callable接口" class="headerlink" title="Thread类、Runnable接和Callable接口"></a>Thread类、Runnable接和Callable接口</h2><p>推荐使用Runnable接口，好处是：</p>
<ol>
<li>接口可以实现多个，突破单继承。</li>
<li><p>便于共享资源。因为一个线程只能启动一次，通过Thread实现线程时，线程和线程所要执行的任务是捆绑在一起的。而一个任务可以启动多个线程，通过Runnable方式实现的线程，实际是开辟一个线程，将任务传递进去，由此线程执行。</p>
</li>
<li><p>Callable接口<br>Callable接口用于juc并发编程</p>
</li>
</ol>
<ul>
<li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li>
<li>call()方法可抛出异常，而run()方法是不能抛出异常的。</li>
<li>运行Callable任务可拿到一个Future对象。</li>
</ul>
<p>Future<br>    Callable任务返回Future对象。即：Callable和Future一个产生结果，一个拿到结果。Future 表示异步计算的结果。</p>
<p><a href="https://www.cnblogs.com/felixzh/p/6044371.html" target="_blank" rel="noopener">Callable接口、Runable接口、Future接口</a></p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda推导必须存在类型</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程只为用户线程服务，JVM不用等待守护线程结束才结束。而JVM默认会等用户线程结束才会结束。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>同步方法与同步块的区别：</p>
<p>1.同步方法<br>同步方法锁定的是this对象，不是方法。<br>即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。代码如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.同步代码块<br>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。代码如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 </p>
<h2 id="选区加锁对象"><a href="#选区加锁对象" class="headerlink" title="选区加锁对象"></a>选区加锁对象</h2><p>加锁的时候应该加在大对象上，防止调用对象不是同一个。</p>
<h2 id="Quartz使用"><a href="#Quartz使用" class="headerlink" title="Quartz使用"></a>Quartz使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建Scheduler工厂</span></span><br><span class="line">SchedulerFactory sf = <span class="keyword">new</span> SchedulerFactory();</span><br><span class="line"><span class="comment">//2. 从工厂中获取调度器</span></span><br><span class="line">Scheduler sched = sf.getScheduler();</span><br><span class="line"><span class="comment">//3. 创建JobDetail</span></span><br><span class="line">JobDetail job = newJob(HelloJob.class).withIdentify(<span class="string">"job1"</span>,<span class="string">"group1"</span>).build();</span><br><span class="line"><span class="comment">//时间</span></span><br><span class="line">Date runTime = evenSecondDateAfterNow();</span><br><span class="line"><span class="comment">//4. 触发条件</span></span><br><span class="line">Trigger trigger = newTrigger().withIdentify(<span class="string">"trigger1"</span>,<span class="string">"group1"</span>).start(runTime).build();</span><br><span class="line"><span class="comment">//5. 注册任务</span></span><br><span class="line">sched.schedulerJob(job,trigger);</span><br><span class="line"><span class="comment">//6. 启动</span></span><br><span class="line">sched.start</span><br></pre></td></tr></table></figure>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>只保证数据同步，当数据修改时立即通知其他持有者更新数据。比synchronized开销小，但不保证操作的原子性。已经很少使用了。</p>
<h2 id="使用double-checking和volatile进行单例设计"><a href="#使用double-checking和volatile进行单例设计" class="headerlink" title="使用double-checking和volatile进行单例设计"></a>使用double-checking和volatile进行单例设计</h2><p>单例模式：套路，在多线程环境下，对外存在一个对象。<br>在懒汉式基础上修改。</p>
<ol>
<li>构造器私有化，防止外部创建</li>
<li>提供私有的静态属性</li>
<li>提供公共的静态方法<br>静态方法示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLocking <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//再次检测，减少不必要的同步。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> !== instance)&#123;<span class="keyword">return</span> instance&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> DoubleCheckedLocking();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">&#125;instance</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ThreadLoacl"><a href="#ThreadLoacl" class="headerlink" title="ThreadLoacl"></a>ThreadLoacl</h2><p>ThreadLoacl：分析上下文、环境、起点。    </p>
<ol>
<li>构造器：哪里调用就属于哪里，找线程体。</li>
<li>run方法：线程本身的。<br>InheritableThreadLoacl：继承上下文，环境的数据，拷贝一份给线程，起点</li>
</ol>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>原理：锁添加计数器，当加锁对象被访问时，判断是否锁定且为当前持有锁对象，否则wait();，是则计数器加1，当计数器为0时说明对象释放锁。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>独占锁，会导致其他线程挂起。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>没有锁，失败重试，直到成功。<br>乐观锁实现方式：Compare and Swap 比较并交换。<br>需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/Effective-Java-3rd第12章(85~90)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/Effective-Java-3rd第12章(85~90)/" itemprop="url">
                  Effective Java 3rd 第12章 序列化(85~90)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-07T16:37:30+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:51:00" itemprop="dateModified" datetime="2019-01-06T21:51:00+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="第12章-序列化"><a href="#第12章-序列化" class="headerlink" title="第12章 序列化"></a>第12章 序列化</h2><h2 id="第85条-尽量不要使用Serializable"><a href="#第85条-尽量不要使用Serializable" class="headerlink" title="第85条 尽量不要使用Serializable"></a>第85条 尽量不要使用Serializable</h2><p>序列化的一个基本问题是它的攻击面太大而无法保护，在对字节流进行反序列化的过程中，该方法可以执行来自这些类型的任何代码。不可信流的反序列化可能导致远程代码执行(RCE)、拒绝服务(DoS)和一系列其他利用。这些方法称为gadget。多个小工具可以协同使用，形成一个小工具链。有时会发现一个小工具链，它足够强大，允许攻击者在底层硬件上执行任意本机代码，只给攻击者提交精心设计的字节流进行反序列化的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deserialization bomb - deserializing this stream takes forever</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] bomb() &#123;</span><br><span class="line">    Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; s1 = root;</span><br><span class="line">    Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        t1.add(<span class="string">"foo"</span>); <span class="comment">// Make t1 unequal to t2</span></span><br><span class="line">        s1.add(t1); s1.add(t2);</span><br><span class="line">        s2.add(t1); s2.add(t2);</span><br><span class="line">        s1 = t1;</span><br><span class="line">        s2 = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialize(root); <span class="comment">// Method omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象图由201个HashSet实例组成，每个实例包含3个或更少的对象引用。整个流的长度为5744字节，但是在反序列化之前sun就已经耗尽了。问题是反序列化哈希集实例需要计算其元素的哈希码。root哈希集的2个元素本身就是包含2个哈希集元素的哈希集，每个哈希集元素包含2个哈希集元素，依此类推，深度为100层。因此，反序列化集合会导致hashCode方法被调用超过2100次。除了反序列化要花费很长时间之外，反序列化器没有任何出错的迹象。生成的对象很少，堆栈深度是有限的。</p>
<p>避免序列化被利用的最佳方法是永远不要反序列化任何东西。没有理由在您编写的任何新系统中使用Java序列化。</p>
<p>有许多其他的跨平台序列化方法，最常用的是以下两个：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>Json</th>
<th>protobuf</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>基于文本的</td>
<td>基于二进制的</td>
</tr>
<tr>
<td>优点</td>
<td>可读性好</td>
<td>高效</td>
</tr>
<tr>
<td>用途</td>
<td>完全是一种数据表示</td>
<td>提供模式(类型)来记录和强制适当的使用</td>
</tr>
<tr>
<td>备注</td>
<td>对于基于文本的表示非常有效</td>
<td>提供了一种可供选择的文本表示，以便在需要人类可读性的地方使用(pbtxt)</td>
</tr>
</tbody>
</table>
<p>总之，序列化是危险的，应该避免。如果您从头开始设计系统，那么可以使用跨平台的结构化数据表示，例如JSON或protobuf。不要反序列化不可信的数据。如果必须这样做，请使用对象反序列化筛选，但要注意，它不能保证阻止所有攻击。避免编写可序列化的类。如果你必须这样做，一定要非常小心。</p>
<h2 id="第86条-非常谨慎地实现可序列化"><a href="#第86条-非常谨慎地实现可序列化" class="headerlink" title="第86条 非常谨慎地实现可序列化"></a>第86条 非常谨慎地实现可序列化</h2><p>虽然使一个类可被序列化的直接开销非常低，甚至可以忽略不计，但是为了序列化而付出的长期开销往往是实实在在的。实现Serializable 接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。如果你接受了默认的序列化形式，这个类中私有的和包级私有的实例域将都变成导出的API的一部分，这不符合“最低限度地访问域”的实践准则（见第15条），从而它就失去了作为信息隐藏工具的有效性。</p>
<ol>
<li><strong>序列化会使类的演变受到限制</strong>，这种限制的一个例子与流的唯一标识符(stream unique identifier)有关，通常它也被称为序列版本UID (serial version UID )</li>
<li><strong>实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性(第85条)</strong>。无论你是接受了默认的行为，还是覆盖了默认的行为，反序列化机制(deserialization)都是一个“隐藏的构造器”，具备与其他构造器相同的特点。因为反序列化机制中没有显式的构造器，所以你很容易忘记要确保：反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，井且不允许攻击者访问正在构造过程中的对象的内部信息。依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受到非法访问（见第88条）。</li>
<li><strong>实现Serializable的第三个成本是，它增加了与发布类的新版本相关联的测试负担</strong>。当一个可序列化的类被修订的时候，要检查是否可以在新版本中序列化一个实例，然后在旧版本中反序列化。</li>
<li><strong>为继承而设计的类(项目19)很少实现可序列化，接口也很少扩展它</strong>。</li>
<li><strong>内部类(项目24)不应该实现可序列化</strong>。它们使用编译器生成的合成字段存储对封闭实例的引用，并存储来自封闭范围的局部变量值。这些字段如何与类定义对应是未指定的，匿名类和本地类的名称也是未指定的。因此，内部类的默认序列化形式是未定义的。然而，静态成员类可以实现序列化。</li>
</ol>
<p>如果一个类将要加入到某个框架中，井且该框架依赖于序列化来实现对象传输或者持久化，对干这个类来说，实现SeriaJizable接口就非常有必要。</p>
<p>总而言之，实现Serializable的易用性是似是而非的。除非类只在受保护的环境中使用，在这种环境中版本永远不必互操作，服务器永远不会暴露于不受信任的数据，否则实现Serializable是一个需要非常小心的严肃承诺。如果类允许继承，则需要格外小心。</p>
<h2 id="第87条-考虑使用自定义的序列化形式"><a href="#第87条-考虑使用自定义的序列化形式" class="headerlink" title="第87条 考虑使用自定义的序列化形式"></a>第87条 考虑使用自定义的序列化形式</h2><p>如果没有先认真考虑默认的序列化形式是否合达，则不要贸然接受。</p>
<p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。使用默认序列化形式会有以下4个缺点：</p>
<ol>
<li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li>
<li>它会消耗过多的空间</li>
<li>它会消耗过多的时间。</li>
<li>它会引起栈溢出。</li>
</ol>
<p>论你是否使用默认的序列化形式，当defaultWriteObject方法被调用的时候，每一个未被标记为transient的实例域都会被序列化。因此，每一个可以被标记为transient的实例域都应该做上这样的标记。在决定将一个域做成非transient 的乏前，请一定要确信它的值将是该对象逻辑状态的一部分。当一个实例被反序列化的时候，这些域将被初始化为它们的默认值(default value)：对于对象引用域，默认值为null,对于数值基本域，默认值为o,对于boolean域，默认值为false</p>
<p>总而言之，当你决定要将一个类做成可序列化的时候（见第86条），讲仔细考虑应该采用什么样的序列化形式。只有当默认的序列化形式能够合理地描述对象的逻辑状态时，才能使用默认的序列化形式；否则就要设计一个自定义的序列化形式，通过它合理地描述对象的状态。你应该分配足够多的时间来设计类的序列化形式，就好像分配足够多的时间来设计它的导出方法一样（见第51条）。正如你无法在将来的版本中去掉导出方法一样，你也不能去掉序列化形式中的域；它们必须被永久地保留下去，以确保序列化兼容性。选择错误的序列化形式对干一个类的复杂性和性能都会有永久的负面影响。</p>
<h2 id="第88条-保护性地编写readObjct方法"><a href="#第88条-保护性地编写readObjct方法" class="headerlink" title="第88条 保护性地编写readObjct方法"></a>第88条 保护性地编写readObjct方法</h2><p>构造器必须检查其参数的有效性（见第38条），并且在必要的时候对参数进行保护性拷贝（见第39条）。</p>
<p>总而言之，每当你编写readObject方法的时候，都要这样想：你正在编写一个公有的构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例。不要假设这个字节流一定代表着一个真正被序列化过的实例。虽然在本条目的例子中，类使用了默认的序列化形式，但是，所有讨论到的有可能发生的问题也同样适用千使用自定义序列化形式的类。下面以摘要的形式给出一些指导方针，有助千编写出更加健壮的readObject方法：</p>
<ul>
<li>对于对象引用埮必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属千这一类别。</li>
<li>对干任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li>
<li>如果整个对象图在被反序列化之后必须进行验证，就应该使用Objectlnput Validation接口[JavaSE6, Serialization]。</li>
<li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li>
</ul>
<h2 id="第89条-若想控制实例，使用Enum比readResolve"><a href="#第89条-若想控制实例，使用Enum比readResolve" class="headerlink" title="第89条 若想控制实例，使用Enum比readResolve"></a>第89条 若想控制实例，使用Enum比readResolve</h2><p>总而言之，你应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控(instance-co?trolled)的类，就必须提供一个readResolver方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p>
<h2 id="第90条-考虑用序列化代理代替序列化实例"><a href="#第90条-考虑用序列化代理代替序列化实例" class="headerlink" title="第90条 考虑用序列化代理代替序列化实例"></a>第90条 考虑用序列化代理代替序列化实例</h2><p>总而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/Effective-Java-3rd第11章(79~84)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Effective-Java-3rd第11章(79~84)/" itemprop="url">
                  Effective Java 3rd 第11章 并发(79~84)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-06T16:37:30+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:49:53" itemprop="dateModified" datetime="2019-01-06T21:49:53+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第11章-并发"><a href="#第11章-并发" class="headerlink" title="第11章 并发"></a>第11章 并发</h1><h2 id="第78条-同步访问共享的可变数据"><a href="#第78条-同步访问共享的可变数据" class="headerlink" title="第78条 同步访问共享的可变数据"></a>第78条 同步访问共享的可变数据</h2><p>为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。这归因于Java语言规范中的内存模型,它规定了一个线程所做的变化何时以及如何变成对其他线程可见。</p>
<p>不要使用Thread.stop，因为它本质上是不安全的。</p>
<p>当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。volatile修饰符就是一种可以接受的同步形式，但要正确地使用它可能需要一些技巧。</p>
<h2 id="第79条-避免过度同步"><a href="#第79条-避免过度同步" class="headerlink" title="第79条 避免过度同步"></a>第79条 避免过度同步</h2><p>依据情况的不同，过度同步可能会导致性能降低、死锁，甚至不确定的行为。</p>
<p>我们正企图在遍历列表的过程中，将一个元素从列表中删除，这是非法的。</p>
<p>将外来方法的调用移出同步的代码块来解决（异常和死锁)问题通常并不太困难。可以通过将外来方法的调用移出同步的代码块.事实上，要将外来方法的调用移出同步的代码块，还有一种更好的方法。自从Java 1.5发行版本以来，Java类库就提供了一个并发集合(concurrent collection), 见第81条。CopyOn WriteArrayList这是专门为此定制的。这是Array List的一种变体。<strong>通过重新拷贝整个底层数组，在这里实现所有的写操作</strong>。由干内部数组永远不改动，因此迭代不需要锁定，速度也非常快。如果大量使用，CopyOoWriteArrayList的性能将大受影响，但是对千观察者列表来说却是很好的，因为它们几乎不改动，并且经常被遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E»observers=</span><br><span class="line"><span class="keyword">new</span> CopyOnWri teArrayL i st&lt;SetObserver&lt;E»();</span><br></pre></td></tr></table></figure></p>
<p>通常，你应该在同步区域内做尽可能少的工作，如果你必须要执行某个很耗时的动作，则应该设法把这个动作移到同步区域的外面，而不违背第78条中的指导方针。</p>
<p>如果你在内部同步了类，就可以使用不同的方法来实现高井发性，例如分拆锁(lock splitting)、分离锁(lock striping)和非阻塞(nonblocking)并发控制。如果方法修改了静态域，那么你也必须同步对这个域的访问，即使它往往只用千单个线程。</p>
<p>简而言之，为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽址限制同步区域内部的工作县。当你在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。在现在这个多核的时代，这比永远不要过度同步来得更重要。只有当你有足够的理由一定要在内部同步类的时候，才应该这么做，同时还应该将这个决定消楚地写到文档中（见第82条）。</p>
<h2 id="第80条-优先选择执行器、任务和流，而不是线程"><a href="#第80条-优先选择执行器、任务和流，而不是线程" class="headerlink" title="第80条 优先选择执行器、任务和流，而不是线程"></a>第80条 优先选择执行器、任务和流，而不是线程</h2><p>对于小型程序或负载较轻的服务器，执行器。newCachedThreadPool通常是一个不错的选择，因为它不需要配置，而且通常“做正确的事情”。</p>
<p>Executor框架被扩展为支持fork-join任务，这些任务由一种称为fork-join池的特殊类型的Executor服务运行。由fork joinask实例表示的fork-join任务可以被分割成更小的子任务，而组成ForkJoinPool的线程不仅可以处理这些任务，还可以相互“窃取”任务，以确保所有线程都处于繁忙状态，从而导致更高的CPU利用率、更高的吞吐量和更低的延迟。编写和调优fork-join任务非常棘手。并行流(Item 48)是在fork连接池之上编写的，假设它们适合当前的任务，则允许您轻松地利用它们的性能优势。</p>
<h2 id="第81条-并发工具优先于wait和notify"><a href="#第81条-并发工具优先于wait和notify" class="headerlink" title="第81条 并发工具优先于wait和notify"></a>第81条 并发工具优先于wait和notify</h2><p>并发集合为标准的集合接口（如List、Queue和Map)提供了高性能的并发实现。为了提供高并发性，这些实现在内部自己管理同步（见第67条）。因此，并发集合中不可能排除并发活动；将它锁定没有什么作用，只会使程序的速度变慢。</p>
<p>非不得已，否则应该优先使用ConcurrentHashMap而不是使用Collections.synchronizedMap 或者Hash table。<strong>只要用并发Map替换老式的同步Map,就可以极大地提升井发应用程序的性能</strong>。更一般地，应该优先使用并发梊合，而不是使用外部同步的集合。</p>
<p>有些集合接口已经通过阻寒操作( blocking operation ) 进行了扩展，它们会一直等待（或者阻寒）到可以成功执行为止。例如，BlockingQueue扩展了Queue接口，并添加了包括take在内的几个方法，它从队列中删除并返回了头元素，如果队列为空，就等待。</p>
<p><strong>同步器</strong>是一些使线程能够等待另一个线程的对象，允许它们协调动作。最常用的同步器是CountDownLatch和Semaphore。较不常用的是CyclicBarrier和Exchanger 。</p>
<p><strong>倒计数锁存器</strong>(Countdown Latch)是一次性障碍，允许一个或者多个线程等待一个或者多个其他线程来做某些事情。CountDownLatch的唯一构造器带有一个int类型的参数，这个int参数是指允许所有在等待的线程袚处理之前，必须在锁存器上调用countDown方法的次数。</p>
<p>对于间歇式的定时，始终应该优先使用System.nanoTime,而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p>
<p>下面是使用wait方法的标准模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The st andard i di0t11 for using the wait 11ethod</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">        obj .wait(); <span class="comment">//- (Releases lock, and reacquires on wakeup)</span></span><br><span class="line">    ... <span class="comment">//Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>始终应该使用wait循环模式来调用wait方法；永远不要在徙环之外调用wait方法</strong>。把wait调用<br>放在一个循环中，以避免在公有可访问对象上的意外或恶意的通知。</p>
<p>简而言之，直接使用wait和notify就像用”并发汇编语言”进行编程一样，而java.util.concurrent则提供了更吓级的语官。没有双由在新代码中使用wait和notify,即使有，也是极少的。如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notify All,而不是使用notify。如果使用notify,诏一定要小心，以确保程序的活性(liveness) 。</p>
<h2 id="第82条-线程安全性文档化"><a href="#第82条-线程安全性文档化" class="headerlink" title="第82条 线程安全性文档化"></a>第82条 线程安全性文档化</h2><p>Javadoc并没有在它的输出中包含synchronized修饰符。因为在一个方法声明中出现synchronized修饰符，这是个实现细节，并不是导出的API的一部分。</p>
<p>一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。</p>
<p>下面的列表概括了线程安全性的儿种级别。这份列表并没有涵盖所有的可能，而只是些常见的情形：</p>
<ol>
<li><strong>不可变的</strong><br> 这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String,Long和Biglnteger</li>
<li><strong>无条件的线程安全</strong><br> 这个类的实例是可变的，但是这个类有若足够的内部同步，所以，它的实例可以被并发使用，无儒任何外部同步。其例子包括Random和ConcurrentHashMap 。</li>
<li><strong>有条件的线程安全</strong><br> 除了有些方法为进行安全的并发使用而带要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.sy nchronized包装返回的集合，它们的迭代器(iterator ) 要求外部同步。</li>
<li><strong>非线程安全</strong><br> 这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap 。</li>
<li><strong>线程对立的</strong><br> 即使每个方法调用都被外部同步所包围，这个类对于并发使用也是不安全的。线程敌意通常是由于在没有同步的情况下修改静态数据而引起的。没有人故意写第82项:文档线程安全331线程敌对类;此类类通常是由于没有考虑并发性而导致的。当一个类或方法被发现是线程不友好的，它通常是固定的或不赞成的。第78项中的generateSerialNumber方法在没有内部同步的情况下是线程不友好的，如第322页所述。</li>
</ol>
<p>这些分类（除了线程对立的之外）粗略对应于《Java Concurrency in Practice 》一书中的<br>线程安全注觥(thread safety annotation) , 分别为<code>Immutable</code>、<code>ThreadSafe</code>和<code>NotThreadsafe</code>。上述分类中无条件和有条件的线程安全类别都涵盖在<code>ThreadSafe</code>注解中了。</p>
<p>私有对象锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private l ock object i dio11 - thwarts denial-of-service attack</span></span><br><span class="line"><span class="keyword">private</span> ·<span class="keyword">final</span> Object lock= <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">synchroni <span class="title">zed</span><span class="params">(lock)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>私有锁对象模式只能用在无条件的线程安全类上。有条件的线程安全类不能使用这种模式。私有锁对象模式特别适用于那些专门为继承而设计的类（见第17 条）。</p>
<p>简而言之，每个类都应该利用字斟句酌的说明或者线程安全注解，渚楚地在文档中说明它的线程安全属性。synchronized修饰符与这个文档毫无关系。有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁”。如果你编写的是无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法。这样可以防止客户端程序和子类的不同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。</p>
<h2 id="第83条-慎用延迟初始化"><a href="#第83条-慎用延迟初始化" class="headerlink" title="第83条 慎用延迟初始化"></a>第83条 慎用延迟初始化</h2><p>虽然延迟初始化主要是一种优化，但它也可以用来打破类和实例初始化中的有害循环。延迟初始化就像一把双刃剑。它降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销。</p>
<p>当有多个线程时，延迟初始化是需要技巧的。如果两个或者多个线程共享一个延迟初始化的域，采用某种形式的同步是很重要的，否则就可能造成严重的Bug(见第66条）。本条目中讨论的所有初始化方法都是线程安全的。</p>
<p>在大多数情况下，正常的初始化要优先于延迟初始化。下面是正常初始化的实例域的一个典型声明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal initialization of an instance field</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br></pre></td></tr></table></figure></p>
<p>如果利用延迟优化来破坏初始化的彼环，就要使用同步访问方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lazy initialization of instance field - synchronized accessor</span></span><br><span class="line"><span class="keyword">private</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="keyword">null</span>)</span><br><span class="line">        field = computeFieldValue();</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果出于性能的考虑而需要对静态域使用延迟初始化，就使用lazy initialization holder class模式。保了类要到被用到的时候才会被初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lazy initialization holder class idiom for static fields</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> FieldHolder.field; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当getFiel~方法第一次被调用时，它第一次读取FieldHolder.field,导致FieldHolder类得到初始化。</p>
<p>如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式。如今，双重检查模式是延迟初始化一个实例域的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Double-check idiom for lazy initialization of instance fields</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FieldType result = field;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123; <span class="comment">// First check (no locking)</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                result= field;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="keyword">null</span>) <span class="comment">// Second check (with locking)</span></span><br><span class="line">                    field = result = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时候，你可能需要延迟初始化一个可以接受重复初始化的实例域，它就是单重检查模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single-check idiom - can cause repeated initialization!</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FieldType result = field;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            field = result = computeFieldValue();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目标，或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的延迟初始化方法。对千实例域，就使用双重检查模式, 对于静态域，则使用lazy initialization holder class idiom。对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式 。</p>
<h2 id="第84条-不要依赖线程调度程序"><a href="#第84条-不要依赖线程调度程序" class="headerlink" title="第84条 不要依赖线程调度程序"></a>第84条 不要依赖线程调度程序</h2><p>任何依赖于<strong>线程调度器</strong>来达到正确性或者性能要求的程序，很有可能都是不可移植的。要编写健壮的、响应良好的、可移植的多线程应用程序，最好的办法是确保可运行线程的平均数址不明显多于处理器的数址。</p>
<p>线程任务应适当地小并彼此独立，但又不能太小，否则分配开销也会影响性能。</p>
<p>线程不应该一直处于忙－等( busy-wait ) 的状态，即反复地检查一个共享对象，以等待<br>某些事情发生。</p>
<p>如果某一个程序不能工作，是因为某些线程无法像其他线程那样获得足够的CPU时间，那么，不要企图通过调用Thread.yield来“修正”该程序，Thread.yield没有可测试的语义，同一个yield调用在一个JVM实现上能提高性能，而在另一个JVM实现上却有可能会更差。</p>
<p>有一种相关的方法是调整线程优先级(thread priority),同样有类似的警告。线程优先级是Java平台上最不可移植的特征了。</p>
<p>简而言之，不要让应用程序的正确性依赖于线程调度器。否则，结果得到的应用程序将既不健壮，也不具有可移植性。作为推论，不要依赖Thread.yield或者线程优先级。这些设施仅仅对调度器作些暗示。线程优先级可以用来提高一个已经能够正常工作的程序的服务质县，但永远不应该用来“修正”一个原本并不能工作的程序。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Effective-Java-3rd第10章(70~78)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Effective-Java-3rd第10章(70~78)/" itemprop="url">
                  Effective Java 3rd 第10章 异常(70~78)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-05T16:37:30+08:00">2018-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:50:56" itemprop="dateModified" datetime="2019-01-06T21:50:56+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第10章-异常"><a href="#第10章-异常" class="headerlink" title="第10章 异常"></a>第10章 异常</h1><h2 id="第69条-只针对异常的情况才使用异常"><a href="#第69条-只针对异常的情况才使用异常" class="headerlink" title="第69条 只针对异常的情况才使用异常"></a>第69条 只针对异常的情况才使用异常</h2><p>总而言之，异常(exception)是为了在异常情况下使用而设计的。不要将它们用干普通的控制流，也不要编写迫使它们这么做的API。</p>
<h2 id="第70条-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#第70条-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="第70条 对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>第70条 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><p>Java程序设计语言提供了三种可抛出结构(throwable) : 受检的异常( checked exception ) 、<br>运行时异常( run-time exception ) 和错误( error ) 。</p>
<p>在决定使用受枪的异常或是未受检的异常时，主要的原则是：<strong>如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常</strong>。</p>
<h2 id="第71条-避免不必要地使用检查过的异常"><a href="#第71条-避免不必要地使用检查过的异常" class="headerlink" title="第71条 避免不必要地使用检查过的异常"></a>第71条 避免不必要地使用检查过的异常</h2><p>在实践中， catch块几乎总是具有断言(assertion)失败的特征。异常受梒的本质并没有为程序员提供任何好处，它反而需要付出努力，还使程序更为复杂。</p>
<p>被一个方法单独抛出的受检异常，会给程序员带来非常高的额外负担。</p>
<p>“把受检的异常变成未受梒的异常”的一种方法是，把这个抛出异常的方法分成两个方法，其中第一个方法返回一个boolean,表明是否应该抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invocat,on with checked exception</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.action(args);</span><br><span class="line">&#125; <span class="keyword">catch</span>(TheCheckedException e) &#123;</span><br><span class="line"><span class="comment">// Handle exceptional condition</span></span><br></pre></td></tr></table></figure></p>
<p>重构为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invocation with state-testing 毗thod and unchecked exception</span></span><br><span class="line">    <span class="keyword">if</span> (obj. actionPermitted(args)) &#123;</span><br><span class="line">        obj.action(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle exceptional condition</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第72条-优先使用标准异常"><a href="#第72条-优先使用标准异常" class="headerlink" title="第72条 优先使用标准异常"></a>第72条 优先使用标准异常</h2><p>Java平台类库提供了一组基本的未受梒的异常，它们满足了绝大多数API的异常抛出需要。</p>
<p>重用现有的异常有多方面的好处：</p>
<ol>
<li>最主要的好处是，它使你的API更加易于学习和使用，因为它与程序员已经熟悉的习惯用法是一致的。</li>
<li>第二个好处是，对干用到这些API的程序而言，<br>它们的可读性会更好，因为它们不会出现很多程序员不熟悉的异常。</li>
<li>最后（也是最不重要的）一点是，异常类越少，意味若内存印迹(footprint)就越小，装载这些类的时间开销也越少。</li>
</ol>
<p>不要直接重用Exception、RuntimeException、Throwable或Error。</p>
<p>常重用的异常有：</p>
<ol>
<li><em>llegalArgumentException</em><br>当调用者传递的参数值不合适的时候，往往就会抛出这个异常。例如，假设一个参数代表了“某个动作的重复次数”，如果程序员给这个参数传递了一个负数，就会抛出这个异常。</li>
<li><em>IllegalStateException</em><br>如果因为接收对象的状态而使调用非法，通常就会抛出这个异常。例如，如果在某个对象被正确地初始化之前，调用者就企图使用这个对象，就会抛出这个异常。</li>
<li><em>ConcurrentModificationException</em><br>如果一个对象被设计为专用千单线程或者与外部同步机制配合使用，一旦发现它正在（或已经）袚并发地修改，就应该抛出这个异常。</li>
<li><em>UnsupportedOperationException</em><br>如果对象不支持所请求的操作，就会抛出这个异常。</li>
</ol>
<table>
<thead>
<tr>
<th>异常</th>
<th>使用场合</th>
</tr>
</thead>
<tbody>
<tr>
<td>IllegalArgumcntException</td>
<td>非null的参数值不正确</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>对于方法调用而言、对象状态不合适</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>在禁止使用null的情况下参数值为null</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>数组下标参数值越界</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>在禁止井发修改的情况下，检测到对象的并发修改</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>对象不支持用户请求的方法</td>
</tr>
</tbody>
</table>
<h2 id="第73条-抛出与抽象相对应的异常"><a href="#第73条-抛出与抽象相对应的异常" class="headerlink" title="第73条 抛出与抽象相对应的异常"></a>第73条 抛出与抽象相对应的异常</h2><p>如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。为了避免这个问题，史高层的实现应该捕荻低层的异常，同时抛出可以按照高层抽象进行斛释的异常。这种做法被称为异常转译(exception translation )，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exception Translation</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    II Use lower-level abstraction to <span class="keyword">do</span> our bidding</span><br><span class="line">    . . .</span><br><span class="line">&#125; <span class="keyword">catch</span>(LowerLevelException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HigherlevelException( . . .);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>高层异常的构造器将原因传到支持链(chaining-aware)的超级构造器，因此它最终将被传给Throwable的其中一个运行异常链的构造器，例如Throwable (Throwable):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exception with chaining-aware constructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherLevelException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    HigherlevelException(Throwable cause) &#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总之，如果无法防止或处理来自较低层的异常，则使用异常转换，除非较低层方法碰巧保证其所有异常都适用于较高级别。异常链提供了两方面的优点:它允许您抛出适当的高级异常，同时捕获失败分析的底层原因(项目75)。</p>
<h2 id="第74条-每个方法抛出的异常都要有文档"><a href="#第74条-每个方法抛出的异常都要有文档" class="headerlink" title="第74条 每个方法抛出的异常都要有文档"></a>第74条 每个方法抛出的异常都要有文档</h2><p><strong>始终要单独地卢明受检的异常，并且利用Javadoc 的<code>@throws</code>标记，准确地记录下抛出每个异常的条件</strong>。<br>如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，而不是为每个方法单独建立文档.</p>
<p>总而言之，要为你编写的每个方法所能抛出的每个异常建立文档。对干未受检和受检的异常，以及对千抽象的和具体的方法也都一样。</p>
<h2 id="第75条-在细节消息中包含能捕获失败的信息"><a href="#第75条-在细节消息中包含能捕获失败的信息" class="headerlink" title="第75条 在细节消息中包含能捕获失败的信息"></a>第75条 在细节消息中包含能捕获失败的信息</h2><ol>
<li>要捕获失败，异常的详细消息应该包含导致异常的所有参数和字段的值。</li>
<li>不要在详细消息中包含密码、加密密钥等。</li>
</ol>
<h2 id="第76条-努力使失败保持原子性"><a href="#第76条-努力使失败保持原子性" class="headerlink" title="第76条 努力使失败保持原子性"></a>第76条 努力使失败保持原子性</h2><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p>
<ol>
<li>对于在可变对象上执行操作的方法，获得失败原子性最常见的办法是，在执行操作之前检查参数的有效性（见第49条）</li>
<li>一种类似的获得失败原子性的办法是，调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。</li>
<li>第三种获得失败原子性的办法远远没有那么常用，做法是编写一段恢复代码( recovery code),由它来拦截操作过程中发生的失败， 以及使对象回滚到操作开始之前的状态上</li>
<li>最后一种获得失败原子性的办法是，在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。如果数据保存在临时的数据结构中，计算过程会更<br>加迅速，使用这种办法就是件很自然的事。</li>
</ol>
<p>一般而言，作为方法规范的一部分，产生的任何异常都应该让对象保持在该方法调用之前的状态。如果违反这条规则， API文档就应该清楚地指明对象将会处千什么样的状态。</p>
<h2 id="第77条-不要忽略异常"><a href="#第77条-不要忽略异常" class="headerlink" title="第77条 不要忽略异常"></a>第77条 不要忽略异常</h2><p>要忽略一个异常非常容易，只需将方法调用通过try语句包围起来，并包含一个<br>空的catch块：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Empty catch block ignores exception - Highly suspect!</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SomeException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>空的catch块会使异常达不到应有的目的</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/Effective-Java-3rd第9章(57~69) /">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/Effective-Java-3rd第9章(57~69) /" itemprop="url">
                  Effective Java 3rd 第9章 一般编程(48~56)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-04 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-04T16:37:30+08:00">2018-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:50:53" itemprop="dateModified" datetime="2019-01-06T21:50:53+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第9章-一般编程"><a href="#第9章-一般编程" class="headerlink" title="第9章 一般编程"></a>第9章 一般编程</h1><h2 id="第57条-最小化局部变量的作用域"><a href="#第57条-最小化局部变量的作用域" class="headerlink" title="第57条 最小化局部变量的作用域"></a>第57条 最小化局部变量的作用域</h2><p>最小化局部变量作用域的最强大技术是在首次使用它的地方声明它。</p>
<h2 id="第58条-与传统的for循环相比，更喜欢for-each循环"><a href="#第58条-与传统的for循环相比，更喜欢for-each循环" class="headerlink" title="第58条 与传统的for循环相比，更喜欢for-each循环"></a>第58条 与传统的for循环相比，更喜欢for-each循环</h2><p>for-each循环通过隐藏迭代器或索引变量来消除混乱和出错的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The preferred idiom for iterating over collections and arrays</span></span><br><span class="line">    <span class="keyword">for</span> (Element e : elements) &#123;</span><br><span class="line">    ... <span class="comment">// Do something with e</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当您看到冒号(:)时，将其读为“in”。因此，上面的循环读作“对于元素中的每个元素e”。使用for-each循环没有性能损失，甚至对于数组也是如此:它们生成的代码基本上与手工编写的代码相同。</p>
<p>不幸的是，有三种常见的情况您不能使用for-each:</p>
<ol>
<li><strong>破坏性筛选</strong>——如果需要遍历一个集合，删除选定的元素，则需要使用显式迭代器，以便调用其删除方法。通过使用Java8中添加的Collection的removeIf方法，通常可以避免显式遍历。</li>
<li><strong>转换</strong>——如果需要遍历列表或数组并替换其元素的部分或全部值，则需要列表迭代器或数组索引来替换元素的值。</li>
<li><strong>并行迭代</strong>——如果您需要并行地遍历多个集合，那么您需要显式地控制迭代器或索引变量，以便所有迭代器或索引变量都可以同步地推进(如上面的bug卡和骰子示例中无意中演示的那样)。</li>
</ol>
<p>for-each循环不仅允许对集合和数组进行迭代，还允许对实现可迭代接口(由单个方法组成)的任何对象进行迭代。写起来是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// Returns an iterator over the elements in this iterable</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第59条-了解和使用依赖"><a href="#第59条-了解和使用依赖" class="headerlink" title="第59条 了解和使用依赖"></a>第59条 了解和使用依赖</h2><p>总之，不要重复发明轮子。如果您需要做一些看起来应该相当常见的事情，那么库中可能已经有一个工具可以完成您想要的工作。</p>
<h2 id="第60条-如果需要准确的答案，应避免使用浮点数和双精度数"><a href="#第60条-如果需要准确的答案，应避免使用浮点数和双精度数" class="headerlink" title="第60条 如果需要准确的答案，应避免使用浮点数和双精度数"></a>第60条 如果需要准确的答案，应避免使用浮点数和双精度数</h2><p>请使用<code>BigDecimal</code>、<code>int</code>或<code>long</code>进行货币计算。</p>
<p>使用BigDecimal的优点是，它可以对舍入进行完全控制，让您在执行需要舍入的操作时从8种舍入模式中进行选择。如果数量不超过9位小数，可以使用int;如果不超过18位，可以使用long。如果数量可能超过18位，请使用BigDecimal。</p>
<h2 id="第61条-原语类型优于装箱原语类型"><a href="#第61条-原语类型优于装箱原语类型" class="headerlink" title="第61条 原语类型优于装箱原语类型"></a>第61条 原语类型优于装箱原语类型</h2><p>在原语和装箱原语之间有三个主要区别。<em>首先</em>，原语只有它们的值，而装箱原语的标识与它们的值不同。换句话说，两个装箱的原语实例可以具有相同的值和不同的标识。<em>第二</em>，基元类型只有全功能值，而每个装箱基元类型除了对应基元类型的所有功能值之外，还有一个非功能值，即null。<em>最后</em>，原语比装箱原语更节省时间和空间。如果你不小心，这三种不同会给你带来真正的麻烦。</p>
<p>在几乎所有情况下，当您在操作中混合原语和装箱原语时，装箱原语都是自动解除装箱的。</p>
<p>总之，无论何时，只要有选择，都要优先使用原语，而不是盒装原语。基本类型更简单、更快。如果必须使用装箱的原语，请小心!自动装箱减少了使用装箱原语的冗长，但没有减少危险。当您的程序将两个装箱原语与==操作符进行比较时，它会进行身份比较，这几乎肯定不是您想要的。当您的程序执行混合类型的计算时，包括已装箱和未装箱的原语时，它将执行解装箱，以及当您的程序执行此操作时<br>解除装箱时，它可以抛出NullPointerException。最后，当您的程序将原语值装箱时，可能会导致创建昂贵且不必要的对象。</p>
<h3 id="附-java中基本类型和包装类的区别："><a href="#附-java中基本类型和包装类的区别：" class="headerlink" title="附 java中基本类型和包装类的区别："></a>附 java中基本类型和包装类的区别：</h3><ol>
<li>包装类创建的是对象，拥有方法和字段.对象的调用都是通过引用对象的地址 ;基本类型不是。</li>
<li>包装类是引用传递 而基本类型是值传递;</li>
<li>变量的值存储在栈里，而对象存储在堆里，相比而言，栈比堆更高效，这也是java保留基本类型的原因。包装类创建的对象，可以使用api提供的一些有用的方法。更为强大。</li>
<li>int 是基本类型，直接存数值。Integer是类，产生对象时用一个引用指向这个对象 .</li>
</ol>
<p>Java把内存划分成两种：一种是栈内存，另一种是堆内存 </p>
<p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配 而实际的对象是在存储堆内存中<br>即<br>  int i = 5;//直接在栈中分配空间 </p>
<p>  Integer i = new Integr(5);//对象是在堆内存中,而i(引用变量)是在栈内存中 </p>
<p>在堆中分配的内存，由java虚拟机的自动垃圾回收器来管理. </p>
<p>因为在堆中分配空间所需的时间远大于从栈中分配存储空间,所以JAVA速度比C慢。</p>
<p>当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装类了。Java中每种基本类型都有相应的包装类。<strong>总的来说，基本类型效率高，装箱类型可以使用扩展的api，功能更强大。</strong></p>
<h2 id="第62条-使用其他类型更合适的时候不应用String"><a href="#第62条-使用其他类型更合适的时候不应用String" class="headerlink" title="第62条 使用其他类型更合适的时候不应用String"></a>第62条 使用其他类型更合适的时候不应用String</h2><p>字符串是枚举类型的糟糕替代品。字符串不能很好地替代聚合类型。<br>基于字符串的API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>基于键的API：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最初的基于字符串的API类型安全是不可能的，而基于键的API类型安全也是困难的，但是通过使ThreadLocal成为一个参数化的类来实现这个API类型安全是一件简单的事情(Item 29)</p>
<p>总之，当存在更好的数据类型或可以编写更好的数据类型时，避免将对象表示为字符串的自然趋势。<strong>如果使用不当，字符串会比其他类型更麻烦、灵活性更差、速度更慢、更容易出错</strong>。字符串经常被误用的类型包括基本类型、枚举和聚合类型。</p>
<h2 id="第63条-注意字符串连接的性能"><a href="#第63条-注意字符串连接的性能" class="headerlink" title="第63条 注意字符串连接的性能"></a>第63条 注意字符串连接的性能</h2><p>重复使用字符串连接运算符来连接n个字符串需要时间为n^2*（单次连接时间）。</p>
<p>道理很简单:除非性能无关，否则不要使用字符串连接操作符组合多个字符串。使用StringBuilder的append方法。或者，使用一个字符数组，或者一次处理一个字符串，而不是组合它们。</p>
<h2 id="第64条-通过接口引用对象"><a href="#第64条-通过接口引用对象" class="headerlink" title="第64条 通过接口引用对象"></a>第64条 通过接口引用对象</h2><p>引用对象应该像这样引用接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good - uses interface as type</span></span><br><span class="line">Set&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>而不是像这样直接用类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad - uses class as type!</span></span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>如果您养成了使用接口作为类型的习惯，那么您的程序将更加灵活。如果不存在合适的接口，则完全可以通过类而不是接口引用对象。</p>
<p>例如，考虑值类，例如String和BigInteger。在编写值类时，很少考虑多个实现。它们通常是最终的，很少有相应的接口。将这样的值类用作参数、变量、字段或返回类型非常合适。</p>
<p>没有合适接口类型的第二种情况是属于框架的对象，框架的基本类型是类而不是接口。如果一个对象属于这样一个基于类的框架，最好通过相关的基类(通常是抽象的)来引用它，而不是通过它的实现类。许多java。io类(如OutputStream)属于这一类别。</p>
<p>最后一种不存在合适接口类型的情况是实现接口但同时提供接口中未找到的额外方法的类——例如，PriorityQueue有一个不在队列接口上的comparator方法。只有当程序依赖于额外的方法时，才应该使用这样的类来引用它的实例，这种情况应该非常少见。</p>
<p>这三种情况并不是详尽无遗的，而仅仅是为了表达按类引用对象是适当的情况。在实践中，一个给定的对象是否具有适当的接口是显而易见的。如果是这样，您的程序将更加灵活和时尚，如果您使用接口来引用对象。<strong>如果没有合适的接口，就使用类层次结构中提供所需功能的最不特定的类</strong>。</p>
<h2 id="第65条-接口优于反射机制"><a href="#第65条-接口优于反射机制" class="headerlink" title="第65条 接口优于反射机制"></a>第65条 接口优于反射机制</h2><p>核心反射机制java.lang.reflect提供了“通过程序来访问关于已装载的类的信息”的能力，给定一个Class实例，可以获得Constructor、Method、Field实例，这些对象提供“通过程序来访问类的成员名称、域类型、方法签名等信息”的能力。</p>
<p>反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在，存在的代价：</p>
<ol>
<li>失去编译时类型检查的好处，包括异常检查。</li>
<li>执行反射访问所需的代码很长。</li>
<li>性能上的损失。</li>
</ol>
<p>反射机制的例子：</p>
<p>创建Set实例，吧命令行参数插入到集合中，然后打印该集合，其中第一个参数指定打印的结果，如果是HashSet以随机的方式打印出来，如果是TreeSet按照字母顺序打印出来的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Class not found"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = (Set&lt;String&gt;) c.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalAccessException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Class not accessible"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InstantiationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Class not instantiable"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.addAll(Arrays.asList(args).subList(<span class="number">1</span>, args.length));</span><br><span class="line">        System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这相当于一个集合测试器，通过反射测试Set实现，同时，它也可以作为通用的集合性能分析工具。<br>这种方法足以完成成熟的服务提供者框架。</p>
<p>总之，反射是一种功能强大的工具，对于某些复杂的系统编程任务是必需的，但是它有许多缺点。如果您编写的程序必须处理编译时未知的类，则应该(如果可能的话)仅使用反射实例化对象，并使用编译时已知的接口或超类访问对象。</p>
<h2 id="第66条-谨慎地使用本地方法"><a href="#第66条-谨慎地使用本地方法" class="headerlink" title="第66条 谨慎地使用本地方法"></a>第66条 谨慎地使用本地方法</h2><p>本地方法,是指本地程序设计语言(c,或者c++)来编写的特殊方法. 本地方法在本地语言中可移植性任意的计算任务,并且返回到java程序语言.</p>
<p>需要真正高性能多精度算法的Java程序员现在可以通过本机方法来使用GMP [Blum14]</p>
<p>为什么说谨慎使用本地方法?</p>
<ol>
<li>由于本机语言不安全(项目50)，使用本机方法的应用程序不再能够避免内存损坏错误。</li>
<li>由于本机语言比Java更依赖于平台，所以使用本机方法的程序可移植性较差,也更难调试。</li>
<li>本机方法可能会降低性能，因为垃圾收集器不能自动化，甚至不能跟踪本机内存使用情况(项目8)。</li>
<li>最后，本机方法需要“粘合代码”，这些代码很难读，而且编写起来也很繁琐。</li>
</ol>
<p>使用本地方法需要三思,极少情况会使用本地方法来提高性能,如果必须访问本地方法访问资源,那也要尽可能少用本地代码,并且要进行全面测试,只要本地代码出现个bug,对系统都有整体的破坏作用.</p>
<h2 id="第67条-谨慎优化"><a href="#第67条-谨慎优化" class="headerlink" title="第67条 谨慎优化"></a>第67条 谨慎优化</h2><p>有三个关于优化的格言:</p>
<ol>
<li>与其他任何单一原因相比，以效率(不一定能实现)的名义犯下的计算机罪更多——包括盲目的愚蠢。</li>
<li>我们应该忘记小的效率，比如97%的情况下:过早的优化是万恶之源。</li>
<li><p>在优化问题上，我们遵循两条规则:<br>规则1:不要这样做。<br>规则2:(仅适用于专家)。现在先别做，也就是说，等你有了一个完全清晰和未优化的解决方案。</p>
</li>
<li><p>努力避免限制性能的设计决策。</p>
</li>
<li>考虑API设计决策的性能后果。为了获得良好的性能而扭曲API是一个非常糟糕的主意</li>
<li>在每次尝试优化之前和之后测量性能。</li>
</ol>
<p>总之，不要努力写快的程序——要努力写好的程序;速度将跟随。但是在设计系统时一定要考虑性能，尤其是在设计api、线级别协议和持久数据格式时。当您完成了系统的构建之后，度量它的性能。如果足够快，你就完成了。如果没有，在分析器的帮助下找到问题的根源，并开始优化系统的相关部分。<strong>第一步是检查您对算法的选择</strong>:低级的优化不能弥补对算法的糟糕选择。根据需要重复这个过程，在每次更改之后测量性能，直到您满意为止。</p>
<h2 id="第68条-遵守公认的命名约定"><a href="#第68条-遵守公认的命名约定" class="headerlink" title="第68条 遵守公认的命名约定"></a>第68条 遵守公认的命名约定</h2><ol>
<li>包的名称应该是层次状的，用句号分隔每个部分。每个部分都包括小写字母和数字（很少使用数字）。包名称的其余部分应该包括一个或者多个描述该包的组成部分。这些组成部分应该比较简短，通常不超过8个字符。鼓励使用有意义的缩写形式。例如，使用<code>util</code>而不是utilities，只取首字母的缩写形式也是可以接受的，例如<code>awt</code>。</li>
<li>类和接口的名称，包括枚举和注解类型的名称，都应该包括一个或者多个单词，每个单词的首字母大写,应该尽扯避免用缩写,使用缩写强烈建议采用仅有首字母大写的形式。</li>
<li>字面惯例的例子</li>
</ol>
<table>
<thead>
<tr>
<th>标识符类型</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>包</td>
<td>com.google.inject, org.joda. time.format</td>
</tr>
<tr>
<td>类或者接口</td>
<td>Timer, FutureTask, LinkedHashMap, H1tpServlet</td>
</tr>
<tr>
<td>常量域</td>
<td>MIN_ VALUE, NEGATIVE_INF!NITY</td>
</tr>
<tr>
<td>方法或者域</td>
<td>remove, ensureCapacity, getCrc</td>
</tr>
<tr>
<td>局部变量杂</td>
<td>i, xref, houseNumber</td>
</tr>
<tr>
<td>类型参数</td>
<td>T, E, K, V, X, Tl, T2</td>
</tr>
</tbody>
</table>
<ol start="4">
<li><p>对于返回boolean值的方法，其名称往往以单词”is” 开头。</p>
</li>
<li><p>如果方法所在的类是个Bean[JavaBeans],就要强制使用以”get” 或者 “set” 开头的形式。</p>
</li>
<li>有些方法的名称值得专门提及。转换对象类型的方法、返回不同类型的独立对象的方法，通常被称为toType, 例如toString和toArray 。</li>
</ol>
<h3 id="附-阿里巴巴命名规则"><a href="#附-阿里巴巴命名规则" class="headerlink" title="附 阿里巴巴命名规则"></a>附 阿里巴巴命名规则</h3><ol>
<li>【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br>反例： <em>name / __name / $Object / name</em> / name$ / Object$</li>
<li>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用。<br>正例： alibaba /  taobao /  youku /  hangzhou 等国际通用的名称，可视同英文。<br>反例： DaZhePromotion [ 打折 ] /  getPingfenByName() [ 评分 ] /  int 某变量 = 3</li>
<li>【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外： DO /  BO  /<br>DTO /  VO /  AO<br>正例： MarcoPolo /  UserDO /  XmlService /  TcpUdpDeal /  TaPromotion<br>反例： macroPolo /  UserDo /  XMLService /  TCPUDPDeal /  TAPromotion</li>
<li>【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从<br>驼峰形式。<br>正例：  localValue /  getHttpMessage() /  inputUserId</li>
<li>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： MAX _ STOCK _ COUNT<br>反例： MAX _ COUNT</li>
<li>【强制】抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类<br>命名以它要测试的类的名称开始，以 Test 结尾。</li>
<li>【强制】中括号是数组类型的一部分，数组定义如下： String[] args;反例：使用 String args[] 的方式来定义。</li>
<li>【强制】 POJO 类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。<br>反例：定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted() ， RPC 框架在反向解析的时候，“以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。</li>
<li>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br>正例： 应用工具类包名为com.alibaba.open.util、类名为MessageUtils（此规则参考spring 的框架结构 ）</li>
<li>【强制】杜绝完全不规范的缩写，避免望文不知义。<br>反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成  condi ，此类随<br>意缩写严重降低了代码的可阅读性。</li>
<li>【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词<br>组合来表达其意。<br>正例：从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。<br>反例：变量 int a; 的随意命名方式。</li>
<li>【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。<br>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br>正例： public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</li>
<li>【推荐】接口类中的方法和属性不要加任何修饰符号 （public 也不要加 ） ，保持代码的简洁<br>性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是<br>与接口方法相关，并且是整个应用的基础常量。</li>
</ol>
<p>正例：接口方法签名： void f();<br>接口基础常量表示： String COMPANY = “ alibaba “ ;<br>反例：接口方法定义： public abstract void f();<br>说明： JDK 8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。</p>
<ol start="14">
<li><p>接口和实现类的命名有两套规则：<br>【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部<br>的实现类用 Impl 的后缀与接口区别。<br>正例： CacheServiceImpl 实现 CacheService 接口。<br>【推荐】 如果是形容能力的接口名称，取对应的形容词做接口名 （ 通常是– able 的形式 ） 。<br>正例： AbstractTranslator 实现  Translatable 。</p>
</li>
<li><p>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字为 ProcessStatusEnum 的 成员名称： SUCCESS /  UNKOWN _ REASON 。</p>
</li>
<li>【参考】各层命名规约：<br>A) Service / DAO 层方法命名规约<br>） 获取单个对象的方法用 get 做前缀。<br>） 获取多个对象的方法用 list 做前缀。<br>） 获取统计值的方法用 count 做前缀。<br>） 插入的方法用 save/insert 做前缀。<br>） 删除的方法用 remove/delete 做前缀。<br>） 修改的方法用 update 做前缀。<br>B) 领域模型命名规约<br>） 数据对象： xxxDO ， xxx 即为数据表名。<br>） 数据传输对象： xxxDTO ， xxx  为业务领域相关的名称<br>） 展示对象： xxxVO ， xxx 一般为网页名称。<br>） POJO 是 DO / DTO / BO / VO 的统称，禁止命名成     xxxPOJO 。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/02/Effective-Java-3rd第8章(48~56) /">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/02/Effective-Java-3rd第8章(48~56) /" itemprop="url">
                  Effective Java 3rd 第8章 Methods(48~56)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-02 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-02T16:37:30+08:00">2018-12-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:50:52" itemprop="dateModified" datetime="2019-01-06T21:50:52+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第8章-方法"><a href="#第8章-方法" class="headerlink" title="第8章 方法"></a>第8章 方法</h1><h2 id="第49条-检查参数有效性"><a href="#第49条-检查参数有效性" class="headerlink" title="第49条 检查参数有效性"></a>第49条 检查参数有效性</h2><p>总而言之，每次编写方法或构造方法时，都应该考虑对其参数存在哪些限制。 应该记在这些限制，并在方法体的开头使用显式检查来强制执行这些限制。 养成这样做的习惯很重要。在第一次有效性检查失败时，它所需要的少量工作将会得到对应的回报。</p>
<h2 id="第50条-必要时进行保护性拷贝"><a href="#第50条-必要时进行保护性拷贝" class="headerlink" title="第50条 必要时进行保护性拷贝"></a>第50条 必要时进行保护性拷贝</h2><p>保护性拷贝是在检查参数的有效性（见笫49条）之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。</p>
<h2 id="第51条-谨慎设计方法签名"><a href="#第51条-谨慎设计方法签名" class="headerlink" title="第51条 谨慎设计方法签名"></a>第51条 谨慎设计方法签名</h2><ol>
<li>谨慎地选择方法的名称</li>
<li>不要过干追求提供便利的方法</li>
<li>避免过长的参数列表，目标是四个参数，或者更少。<br> 缩短参数列表的方法有：  <ol>
<li>是把方法分解成多个方法。</li>
<li>创建辅助类</li>
<li>采用Builder模式（请见第2 条）</li>
</ol>
</li>
</ol>
<h2 id="第52条-慎用重载"><a href="#第52条-慎用重载" class="headerlink" title="第52条 慎用重载"></a>第52条 慎用重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Broken! - What does this p卤ram print?</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Col</span> <span class="title">l</span> <span class="title">ectionClassifier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Set"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; <span class="number">1</span>st)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"List"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">publ ic <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown Collection"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Collection&lt;?&gt; c : collections)</span><br><span class="line">        System.out.println(classify(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的编译时类型都是相同的：Collection&lt;?&gt;。每次迭代的运行时类型都是不同的，但这并不影响对重载方法的选择。因为该参数的编译时类型为Collection&lt;?&gt;，所以，唯一合适的重载方法是第三个： classify(Collection&lt;?&gt;), 在循环的每次迭代中，都会调用这个重载方法。</p>
<p>这个程序的行为有悖常理，因为对于重载方法的选择是静态的，而对于被履盖的方法的选择则是动态的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"wine"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparklingWine</span> <span class="keyword">extends</span> <span class="title">Wine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"sparkling wine"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Champagne</span> <span class="keyword">extends</span> <span class="title">SparklingWine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"champagne"</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overriding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Wine&gt; wineList = List.of(<span class="keyword">new</span> Wine(), <span class="keyword">new</span> SparklingWine(), <span class="keyword">new</span> Champagne());</span><br><span class="line">        <span class="keyword">for</span> (Wine wine : wineList)</span><br><span class="line">            System.out.println(wine.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所预期的那样，这个程序打印出”wine, sparkling wine和champagne”，尽管在循环的每次迭代中，实例的编译时类型都为Wine。当调用被覆盖的方法时，对象的编译时类型不会影响到哪个方法将被执行； “最为具体的(most specific)”那个覆盖版本总是会得到执行。这与重载的情形相比，对象的运行时类型并不影响“哪个重载版本将被执行”；选择工作是在编译时进行的，完全基于参数的编译时类型。</p>
<p>安全而保守的菜略是，永远不要导出两个具有相同未数数目的重载方法。如果方法使用可变参数( varargs ),保守的策略是根本不要重载它，除第53条中所述的情形之外。如果对于每一对重载方法，至少有一个对应的参数在两个重载方法中具有“根本不同(radically different)” 的类型。在这种情况下，一组给定的实际参数应用千哪个重载方法上就完全由参数的运行时类型来决定。</p>
<h2 id="第53条-慎用可变参数"><a href="#第53条-慎用可变参数" class="headerlink" title="第53条 慎用可变参数"></a>第53条 慎用可变参数</h2><p>简而言之，在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被过度滥用。</p>
<h2 id="第54条-返回零长度的数组或集合，而不是null"><a href="#第54条-返回零长度的数组或集合，而不是null" class="headerlink" title="第54条 返回零长度的数组或集合，而不是null"></a>第54条 返回零长度的数组或集合，而不是null</h2><p>简而言之，返回类型为数组或集合的方法没理由返回null , 而不是返回一个零长度的数组或者集合。这种习惯做法（指返回null)很有可能是从C程序设计语言中沿袭过来的，在C语言中，数组长度是与实际的数组分开返回的。在C语言中，如果返回的数组长度为零，再分配一个数组就没有任何好处。</p>
<h2 id="第55条-明智而审慎地返回optionals类型"><a href="#第55条-明智而审慎地返回optionals类型" class="headerlink" title="第55条 明智而审慎地返回optionals类型"></a>第55条 明智而审慎地返回optionals类型</h2><p>抛出异常花销比较大<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns maximum value in collection as an Optional&lt;E&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt;</span><br><span class="line"><span class="function">Optional&lt;E&gt; <span class="title">max</span><span class="params">(Collection&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">        </span><br><span class="line">    E result = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (E e : c)</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> || e.compareTo(result) &gt; <span class="number">0</span>)</span><br><span class="line">            result = Objects.requireNonNull(e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Optional.of(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第56条-为所有公开的API元素编写文档注释"><a href="#第56条-为所有公开的API元素编写文档注释" class="headerlink" title="第56条 为所有公开的API元素编写文档注释"></a>第56条 为所有公开的API元素编写文档注释</h2><p>Javadoc利用特殊格式的文档注释( documentation comment, 通常被写作doc comment) , 根据源代码自动产生API文档。</p>
<p>在Java 9中添加了一个重要的doc标记，{@index};Java 8中的一个，{@ impspec};Java 5中有两个，{@literal}和{@code}。上述web页面中缺少这些标记，但将在本项目中进行讨论。</p>
<ol>
<li>要正确地记录API，必须在每个导出的类、接口、构造函数、方法和字段声明之前加上doc注释。</li>
<li>方法的文档注释应该简洁地描述方法与其客户之间的契约。</li>
<li>文档注释应该在源代码和生成的文档中都是可读的。</li>
<li>类或接口中的两个成员或构造函数不应该具有相同的摘要描述.</li>
<li>在记录泛型类型或方法时，请确保记录所有类型参数。</li>
<li>在记录枚举类型时，一定要记录常量。</li>
<li>在记录注释类型时，一定要记录任何成员</li>
<li>不管类或静态方法是否是线程安全的，都应该记录它的线程安全</li>
<li>读取Javadoc实用程序生成的web页面</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/25/Effective-Java-3rd第7章(42~48) /">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/25/Effective-Java-3rd第7章(42~48) /" itemprop="url">
                  Effective Java 3rd 第7章 Lambda表达式和流(41~48)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-25 16:37:30 / 修改时间：23:58:30" itemprop="dateCreated datePublished" datetime="2018-11-25T16:37:30+08:00">2018-11-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第七章-Lambda与流"><a href="#第七章-Lambda与流" class="headerlink" title="第七章 Lambda与流"></a>第七章 Lambda与流</h1><h2 id="第42条-lambda表达式优于匿名类"><a href="#第42条-lambda表达式优于匿名类" class="headerlink" title="第42条 lambda表达式优于匿名类"></a>第42条 lambda表达式优于匿名类</h2><p>在某些情况下，编译器将无法确定类型，必须指定它们。 类型推断的规则很复杂。很少有程序员详细了解这些规则，但没关系。 除非它们的存在使你的程序更清晰，否则省略所有lambda参数的类型。</p>
<p>关于类型推断需要注意一点，因为编译器获得了大部分允许它从泛型进行类型推断的类型信息。如果你没有提供这些信息，编译器将无法进行类型推断，你必须在lambdas中手动指定类型。</p>
<p>与方法和类不同，lambda没有名称和文档;<strong>如果计算不是自解释的，或者超过几行，则不要将其放入lambda表达式中</strong>。一行代码对于lambda说是理想的，三行代码是合理的最大值。</p>
<p>Lambda仅限于函数式接口。如果你想创建一个抽象类的实例，你可以使用匿名类来实现，但不能使用lambda。 </p>
<p>应该很少(如果有的话)序列化一个lambda(或一个匿名类实例)。</p>
<p>综上所述，从Java8开始，lambda是迄今为止表示小函数对象的最佳方式。<strong>除非必须创建非函数式接口类型的实例，否则不要使用匿名类作为函数对象</strong>。 </p>
<h2 id="第43条方法引用优于lambda表达式"><a href="#第43条方法引用优于lambda表达式" class="headerlink" title="第43条方法引用优于lambda表达式"></a>第43条方法引用优于lambda表达式</h2><p>使用方法引用的代码段既不比使用lambda的代码片段更短也不清晰，所以更喜欢后者。 </p>
<p>多方法引用是指静态方法，但有四种方法没有。 其中两个是特定（bound）和任意（unbound）对象方法引用。 在特定对象引用中，接收对象在方法引用中指定。 特定对象引用在本质上与静态引用类似：函数对象与引用的方法具有相同的参数。 在任意对象引用中，接收对象在应用函数对象时通过方法的声明参数之前的附加参数指定。 任意对象引用通常用作流管道（pipelines）中的映射和过滤方法（条目 45）。 最后，对于类和数组，有两种构造方法引用。 构造方法引用用作工厂对象。 下表总结了所有五种方法引用：</p>
<table>
<thead>
<tr>
<th>方法引用类型</th>
<th>举例</th>
<th>等同的Lambda</th>
</tr>
</thead>
<tbody>
<tr>
<td>Static</td>
<td>Integer::parseInt</td>
<td>str -&gt; Integer.parseInt(str)</td>
</tr>
<tr>
<td>Bound</td>
<td>Instant.now()::isAfter</td>
<td>Instant then = Instant.now(); t -&gt; then.isAfter(t)</td>
</tr>
<tr>
<td>Unbound</td>
<td>String::toLowerCase</td>
<td>str -&gt; str.toLowerCase()</td>
</tr>
<tr>
<td>Class Constructor</td>
<td>TreeMap&lt;K,V&gt;::new</td>
<td>() -&gt; new TreeMap&lt;K,V&gt;</td>
</tr>
<tr>
<td>Array Constructor</td>
<td>int[]::new</td>
<td>len -&gt; new int[len]</td>
</tr>
</tbody>
</table>
<p>总之，方法引用通常为lambda提供一个更简洁的选择。 <strong>如果方法引用看起来更简短更清晰，请使用它们；否则，还是坚持lambda。</strong></p>
<h2 id="第44条-优先使用标准的函数式接口"><a href="#第44条-优先使用标准的函数式接口" class="headerlink" title="第44条 优先使用标准的函数式接口"></a>第44条 优先使用标准的函数式接口</h2><p>在java.util.Function中有43个接口,如果记住了六个基本接口，就可以在需要它们时派生出其余的接口。</p>
<p>基本接口操作于对象引用类型。<code>Operator</code>接口表示方法的结果和参数类型相同。<code>Predicate</code>接口表示其方法接受一个参数并返回一个布尔值。<code>Function</code>接口表示方法其参数和返回类型不同。<code>Supplier</code>接口表示一个不接受参数和返回值(或“供应”)的方法。最后，<code>Consume</code>r表示该方法接受一个参数而不返回任何东西，本质上就是使用它的参数。六种基本函数式接口概述如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>方法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>UnaryOperator<t></t></td>
<td>T apply(T t)</td>
<td>String::toLowerCase</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T apply(T t1, T t2)</td>
<td>BigInteger::add</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>boolean test(T t)</td>
<td>Collection::isEmpty</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>R apply(T t)</td>
<td>Arrays::asList</td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td>T get()</td>
<td>Instant::now</td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>void accept(T t)</td>
<td>System.out::println</td>
</tr>
</tbody>
</table>
<p>在处理基本类型int，long和double的操作上，六个基本接口中还有三个变体。<strong>它们的名字是通过在基本接口前加一个基本类型而得到的</strong>。因此，例如，一个接受int的Predicate是一个IntPredicate，而一个接受两个long值并返回一个long的二元运算符是一个LongBinaryOperator。除Function接口变体通过返回类型进行了参数化，其他变体类型都没有参数化。例如，LongFunction&lt;int[]&gt;使用long类型作为参数并返回了int []类型。</p>
<p>Function接口还有九个额外的变体，当结果类型为基本类型时使用。源和结果类型总是不同，因为从类型到它自身的函数是UnaryOperator。 <strong>如果源类型和结果类型都是基本类型，则使用带有SrcToResult的前缀Function</strong>，例如LongToIntFunction(六个变体)。如果源是一个基本类型，返回结果是一个对象引用，那么带有<src>ToObj的前缀Function，例如DoubleToObjFunction (三种变体)。</src></p>
<p><strong>不要试图使用基本的函数式接口来装箱基本类型的包装类而不是基本类型的函数式接口</strong>。虽然它起作用，但它违反了第61条中的建议：“优先使用基本类型而不是基本类型的包装类”。使用装箱基本类型的包装类进行批量操作的性能后果可能是致命的。(内存过载)</p>
<p>总之，现在Java已经有了lambda表达式，因此必须考虑lambda表达式来设计你的API。 在输入上接受函数式接口类型并在输出中返回它们。 一般来说，最好使用java.util.function.Function中提供的标准接口，但请注意，在相对罕见的情况下，最好编写自己的函数式接口。</p>
<h2 id="第45条-明智审慎地使用Stream"><a href="#第45条-明智审慎地使用Stream" class="headerlink" title="第45条 明智审慎地使用Stream"></a>第45条 明智审慎地使用Stream</h2><p>管道延迟（lazily）计算求值：计算直到终结操作被调用后才开始，而为了完成终结操作而不需要的数据元素永远不会被计算出来。 </p>
<p>Stream API流式的（fluent）：：它设计允许所有组成管道的调用被链接到一个表达式中。</p>
<p>默认情况下，<strong>流管道按顺序(sequentially)运行</strong>。 使管道并行执行就像在管道中的任何流上调用并行方法一样简单，但很少这样做（第48个条目）</p>
<p>Stream API具有足够的通用性，<strong>实际上任何计算都可以使用Stream执行</strong>。如果使用得当，流可以使程序更短更清晰；如果使用不当，它们会使程序难以阅读和维护。</p>
<p><strong>在没有显式类型的情况下，仔细命名lambda参数对于流管道的可读性至关重要</strong>。<strong>使用辅助方法对于流管道中的可读性比在迭代代码中更为重要</strong>，因为管道缺少显式类型信息和命名临时变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello world!"</span>.chars().forEach(System.out::print);</span><br></pre></td></tr></table></figure>
<p>你可能希望它打印Hello world!，但如果运行它，发现它打印721011081081113211911111410810033。这是因为“Hello world!”.chars()返回的流的元素不是char值，而是int值，因此调用了print的int重载。无可否认，一个名为chars的方法返回一个int值流是令人困惑的。可以通过强制调用正确的重载来修复该程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello world!"</span>.chars().forEach(x -&gt; System.out.print((<span class="keyword">char</span>) x));</span><br></pre></td></tr></table></figure></p>
<p>但理想情况下，<strong>应该避免使用流来处理char值</strong>。</p>
<p>流管道使用<strong>函数对象</strong>(通常为lambdas或方法引用)表示重复计算，而迭代代码使用<strong>代码块</strong>表示重复计算</p>
<p>从代码块中可以做一些从函数对象中不能做的事情:</p>
<ol>
<li>从代码块中，可以读取或修改范围内的任何局部变量; 从lambda中，只能读取最终或有效的最终变量[JLS 4.12.4]，并且无法修改任何局部变量。</li>
<li>从代码块中，可以从封闭方法返回，中断或继续封闭循环，或抛出声明此方法的任何已检查异常; 从一个lambda你不能做这些事情。</li>
</ol>
<p>流可以很容易地做一些事情：</p>
<ol>
<li>统一转换元素序列</li>
<li>过滤元素序列</li>
<li>使用单个操作组合元素序列(例如添加、连接或计算最小值)</li>
<li>将元素序列累积到一个集合中，可能通过一些公共属性将它们分组</li>
<li>在元素序列中搜索满足某些条件的元素</li>
</ol>
<p>让我们编写一个程序来打印前20个梅森素数(Mersenne primes)。 梅森素数是一个2p − 1形式的数字。如果p是素数，相应的梅森数可能是素数; 如果是这样的话，那就是梅森素数。 作为我们管道中的初始流，我们需要所有素数。 这里有一个返回该（无限）流的方法。 我们假设使用静态导入来轻松访问BigInteger的静态成员：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法的名称（primes）是一个复数名词，描述了流的元素。<strong>强烈建议所有返回流的方法使用(primes)命名</strong>，因为它增强了流管道的可读性。</p>
<p>该方法使用静态工厂Stream.iterate，它接受两个参数：流中的第一个元素，以及从前一个元素生成流中的下一个元素的函数。 这是打印前20个梅森素数的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">        .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>))</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序是上面的梅森描述的直接编码：它从素数开始，计算相应的梅森数，过滤掉除素数之外的所有数字（幻数50控制概率素性测试the magic number 50 controls the probabilistic primality test），将得到的流限制为20个元素， 并打印出来。</p>
<p>总之，有些任务最好使用流来完成，有些任务最好使用迭代来完成。将这两种方法结合起来，可以最好地完成许多任务。对于选择使用哪种方法进行任务，没有硬性规定，但是有一些有用的启发式方法。在许多情况下，使用哪种方法将是清楚的；在某些情况下，则不会很清楚。如果不确定一个任务是通过流还是迭代更好地完成，那么尝试这两种方法，看看哪一种效果更好。</p>
<h2 id="第46条-优先考虑流中无副作用的函数"><a href="#第46条-优先考虑流中无副作用的函数" class="headerlink" title="第46条 优先考虑流中无副作用的函数"></a>第46条 优先考虑流中无副作用的函数</h2><p>为了获得流提供的可表达性、速度和某些情况下的并行性，你必须采用范式和API。纯函数的结果仅取决于其输入：它不依赖于任何可变状态，也不更新任何状态。为了实现这一点，你传递给流操作的任何函数对象（中间操作和终结操作）都应该没有副作用。</p>
<p>Java程序员知道如何使用for-each循环，而forEach终结操作是类似的。 但forEach操作是终端操作中最不强大的操作之一，也是最不友好的流操作。 它是明确的迭代，因此不适合并行化。 <strong>forEach操作应仅用于报告流计算的结果，而不是用于执行计算</strong>。有时，将forEach用于其他目的是有意义的，例如将流计算的结果添加到预先存在的集合中。<br>将流的元素收集到真正的集合中的收集器非常简单。有三个这样的收集器:toList()、toSet()和toCollection(collectionFactory)。它们分别返回集合、列表和程序员指定的集合类型。有了这些知识，我们就可以编写一个流管道从我们的频率表中提取出现频率前10个单词的列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pipeline to get a top-ten list of words from a frequency table</span></span><br><span class="line">List&lt;String&gt; topTen = freq.keySet().stream()</span><br><span class="line">    .sorted(comparing(freq::get).reversed())</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p><strong>静态导入收集器的所有成员是一种惯例和明智的做法，因为它使流管道更易于阅读。</strong>  </p>
<h3 id="toMap"><a href="#toMap" class="headerlink" title="toMap"></a>toMap</h3><ol>
<li>toMap的两个参数形式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Artist, Album&gt; topHits = albums.collect(</span><br><span class="line">   toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales))));</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. toMap的三个参数形式</span><br><span class="line">```java</span><br><span class="line"><span class="comment">// Collector to impose last-write-wins policy</span></span><br><span class="line">toMap(keyMapper, valueMapper, (oldVal, newVal) -&gt;newVal)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li>toMap的四个参数形式<br>它是一个map工厂，用于指定特定的map实现，例如EnumMap或TreeMap。</li>
</ol>
<h3 id="grouping-By"><a href="#grouping-By" class="headerlink" title="grouping By"></a>grouping By</h3><ol>
<li>该方法返回收集器以生成基于分类器函数(classifier function)将元素分组到类别中的map。 分类器函数接受一个元素并返回它所属的类别。 此类别来用作元素的map的键。 groupingBy方法的最简单版本仅采用分类器并返回一个map，其值是每个类别中所有元素的列表。</li>
</ol>
<pre><code class="java">Map&lt;String, Long&gt; freq = words
    .collect(groupingBy(String::toLowerCase, counting()));
</code></pre>
<ol start="2">
<li>groupingBy的第三个版本允许指定除downstream收集器之外的map工厂。请注意，这种方法违反了标准的可伸缩参数列表模式.</li>
</ol>
<p>最后的Collectors中方法是join，它仅对CharSequence实例（如字符串）的流进行操作。 在其无参数形式中，它返回一个简单地连接元素的收集器。 它的一个参数形式采用名为delimiter的单个CharSequence参数，并返回一个连接流元素的收集器，在相邻元素之间插入分隔符。 如果传入逗号作为分隔符，则收集器将返回逗号分隔值字符串（但请注意，如果流中的任何元素包含逗号，则字符串将不明确）。 除了分隔符之外，三个参数形式还带有前缀和后缀。 生成的收集器会生成类似于打印集合时获得的字符串，例如[came, saw, conquered]。</p>
<p>总之，编程流管道的本质是无副作用的函数对象。 这适用于传递给流和相关对象的所有许多函数对象。<strong>终结操作orEach仅应用于报告流执行的计算结果，而不是用于执行计算。</strong> 为了正确使用流，必须了解收集器。。 最重要的收集器工厂是<strong>toList，toSet，toMap，groupingBy和join</strong>。</p>
<p>==附流的常用函数（待完善）==</p>
<h2 id="第47条-优先使用Collection而不是Stream来作为方法的返回类型"><a href="#第47条-优先使用Collection而不是Stream来作为方法的返回类型" class="headerlink" title="第47条 优先使用Collection而不是Stream来作为方法的返回类型"></a>第47条 优先使用Collection而不是Stream来作为方法的返回类型</h2><p>Collection接口是Iterable的子类型，并且具有stream方法，因此它提供迭代和流访问。 因此，Collection或适当的子类型通常是公共序列返回方法的最佳返回类型。 </p>
<p>Stream.concat方法用于将空列表添加到返回的流中。 还有，flatMap方法（条目 45）用于生成由所有前缀的所有后缀组成的单个流。</p>
<p>如果返回集合是可行的，请执行此操作。 如果已经拥有集合中的元素，或者序列中的元素数量足够小，可以创建一个新的元素，那么返回一个标准集合，比如ArrayList。 否则，请考虑实现自定义集合</p>
<h2 id="第48条-谨慎使用流并行"><a href="#第48条-谨慎使用流并行" class="headerlink" title="第48条 谨慎使用流并行"></a>第48条 谨慎使用流并行</h2><p><strong>如果源来自Stream.iterate方法，或者使用中间操作limit方法，并行化管道也不太可能提高其性能</strong>。</p>
<p>通常，并行性带来的性能收益在<strong>ArrayList、HashMap、HashSet和ConcurrentHashMap实例、数组、int类型范围和long类型</strong>的范围的流上最好。<br>这些数据结构的共同之处在于，它们都可以精确而廉价地分割成任意大小的子程序，这使得在并行线程之间划分工作变得很容易。所有这些数据结构的共同点的另一个重要因素是它们在顺序处理时提供了从良好到<strong>极好的引用位置</strong>。</p>
<p>使用映射器（mappers），过滤器（filters）和其他程序员提供的不符合其规范的功能对象的管道并行化可能会导致安全故障。例如，传递给Stream的reduce方法操作的累加器（accumulator）和组合器（combiner）函数必须是关联的，非干扰的和无状态的。</p>
<p>重要的是要记住并行化流是严格的性能优化。 <strong>与任何优化一样，必须在更改之前和之后测试性能，以确保它值得做</strong>（第67项）通常，程序中的所有并行流管道都在公共fork-join池中运行。 单个行为不当的管道可能会损害系统中不相关部分的其他行为。</p>
<p>总之，甚至不要尝试并行化流管道，除非你有充分的理由相信它将保持计算的正确性并提高其速度。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">小华</p>
              <p class="site-description motion-element" itemprop="description">个人学习博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小华</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
