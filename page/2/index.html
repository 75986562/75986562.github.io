<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人学习博客">
<meta property="og:type" content="website">
<meta property="og:title" content="萌面超人">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="萌面超人">
<meta property="og:description" content="个人学习博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="萌面超人">
<meta name="twitter:description" content="个人学习博客">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>萌面超人</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">萌面超人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">
    <a href="/404/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/线程池原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/线程池原理/" itemprop="url">
                  线程池原理解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-06 16:37:30" itemprop="dateCreated datePublished" datetime="2019-01-06T16:37:30+08:00">2019-01-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-06 21:20:30" itemprop="dateModified" datetime="2018-01-06T21:20:30+08:00">2018-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池原理解析"><a href="#线程池原理解析" class="headerlink" title="线程池原理解析"></a>线程池原理解析</h1><p>参考：JAVA线程池原理详解一</p>
<h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><p>线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。<br>可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。</p>
<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,    //线程池核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,//线程池最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,//当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,//存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//存放任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span><span class="comment">//超出线程范围和队列容量的任务的处理程序</span></span></span><br></pre></td></tr></table></figure>
<p>corePoolSize：线程池核心线程数量<br>maximumPoolSize:线程池最大线程数量<br>keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间<br>unit：存活时间的单位<br>workQueue：存放任务的队列<br>handler：超出线程范围和队列容量的任务的处理程序</p>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>提交一个任务到线程池中，线程池的处理流程如下：</p>
<ol>
<li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<p>线程池容器–&gt;集合(ArrayList,HashSrt,LinkedList<thread>,HashMap)<br>当程序第一次启动的时候，创建多个线程池，保存到一个集合中，当要使用的时候就取出来：<br>Thread t = list.remove(0);//返回的是被移除的元素<br>Thread t  = Linked。removeFist();<br>当使用完毕时归还：<br>list.add(t);<br>linked.addList(t);</thread></p>
<h2 id="线程池使用步骤"><a href="#线程池使用步骤" class="headerlink" title="线程池使用步骤"></a>线程池使用步骤</h2><ol>
<li>使用线程池工厂类Executors中的newFixedThreadPool产生一个指定线程数的线程池</li>
<li>创建一个类，实现Runnable接口，设置线程任务。</li>
<li>调用ExecutorsService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</li>
<li>调用ExecutorsService中的方法shutdown销毁线程池（不建议执行）</li>
</ol>
<p>线程池的源码解读<br>1、ThreadPoolExecutor的execute()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">　　　　　　 <span class="comment">//如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">　　　　　　　　　　<span class="comment">//线程池处于运行状态并且加入队列成功</span></span><br><span class="line">            <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                    ensureQueuedTaskHandled(command);</span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　　　<span class="comment">//线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">　　　　　　　　　　　<span class="comment">//创建线程失败，则采取阻塞处理的方式</span></span><br><span class="line">                reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、创建线程的方法：addIfUnderCorePoolSize(command)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">                t = addThread(firstTask);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过一个程序来观察线程池的工作原理：</p>
<ol>
<li><p>创建一个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolTest implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(300);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池循环运行16个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkedBlockingQueue&lt;Runnable&gt; queue =</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>);</span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.SECONDS, queue);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            threadPool.execute(</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadPoolTest(), <span class="string">"Thread"</span>.concat(i + <span class="string">""</span>)));</span><br><span class="line">            System.out.println(<span class="string">"线程池中活跃的线程数： "</span> + threadPool.getPoolSize());</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"----------------队列中阻塞的线程数"</span> + queue.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">线程池中活跃的线程数： <span class="number">1</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">2</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">3</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">4</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">1</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">2</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">3</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">4</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">5</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">6</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">7</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">8</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">9</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">线程池中活跃的线程数： <span class="number">10</span></span><br><span class="line">----------------队列中阻塞的线程数<span class="number">5</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,<span class="number">5</span>,main] rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">232204</span>a1[Running, pool size = <span class="number">10</span>, active threads = <span class="number">10</span>, queued tasks = <span class="number">5</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2047</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">823</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1369</span>)</span><br><span class="line">    at test.ThreadTest.main(ThreadTest.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure></p>
<p>从结果可以观察出：</p>
<ol>
<li>创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。</li>
<li>我们通过queue.size()的方法来获取工作队列中的任务数。</li>
<li>运行原理：<br>   <strong>刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。当然，为了达到我需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放！！！</strong></li>
</ol>
<h2 id="RejectedExecutionHandler：饱和策略"><a href="#RejectedExecutionHandler：饱和策略" class="headerlink" title="RejectedExecutionHandler：饱和策略"></a>RejectedExecutionHandler：饱和策略</h2><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略：</p>
<ol>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用所在的线程运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/模板/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/模板/" itemprop="url">
                  模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 16:37:30" itemprop="dateCreated datePublished" datetime="2019-01-03T16:37:30+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-05 21:20:30" itemprop="dateModified" datetime="2019-01-05T21:20:30+08:00">2019-01-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/模板/" itemprop="url" rel="index"><span itemprop="name">模板</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/Nginx配置简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/31/Nginx配置简介/" itemprop="url">
                  Nginx配置简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-31 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-31T16:37:30+08:00">2018-12-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-03-15 21:20:30" itemprop="dateModified" datetime="2019-03-15T21:20:30+08:00">2019-03-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/工具类/" itemprop="url" rel="index"><span itemprop="name">工具类</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx-简介"><a href="#Nginx-简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h1><h2 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h2><ol>
<li>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理</li>
<li>负载均衡</li>
<li>web缓存</li>
</ol>
<h2 id="Nginx配置文件结构"><a href="#Nginx配置文件结构" class="headerlink" title="Nginx配置文件结构"></a>Nginx配置文件结构</h2><p><a href="https://www.cnblogs.com/knowledgesea/p/5175711.html" target="_blank" rel="noopener">nginx文件结构</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li>
<li>events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li>
<li>http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li>
<li>server块：配置虚拟主机的相关参数，一个http中可以有多个server。</li>
<li>location块：配置请求的路由，以及各种页面的处理情况。</li>
</ol>
<h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><p><a href="https://www.cnblogs.com/liang-wei/p/5849771.html" target="_blank" rel="noopener">nginx配置文件nginx.conf超详细讲解</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#nginx进程,一般设置为和cpu核数一样</span><br><span class="line">worker_processes 4;                        </span><br><span class="line">#错误日志存放目录 </span><br><span class="line">error_log  /data1/logs/error.log  crit;  </span><br><span class="line">#运行用户，默认即是nginx，可不设置</span><br><span class="line">user nginx       </span><br><span class="line">#进程pid存放位置</span><br><span class="line">pid        /application/nginx/nginx.pid;        </span><br><span class="line"></span><br><span class="line">#Specifies the value for maximum file descriptors that can be opened by this process. </span><br><span class="line">#最大文件打开数（连接），可设置为系统优化后的ulimit -HSn的结果</span><br><span class="line">worker_rlimit_nofile 51200;</span><br><span class="line"></span><br><span class="line">cpu亲和力配置，让不同的进程使用不同的cpu</span><br><span class="line"></span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000 0001 00100100 1000;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">events </span><br><span class="line">&#123;</span><br><span class="line">  use epoll;       #epoll是多路复用IO(I/O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">  worker_connections 1024;  #;单个后台worker process进程的最大并发链接数</span><br><span class="line">&#125;</span><br><span class="line">###################################################</span><br><span class="line">http </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">include mime.types; #文件扩展名与类型映射表</span><br><span class="line">default_type application/octet-stream; #默认文件类型</span><br><span class="line"></span><br><span class="line">#limit模块，可防范一定量的DDOS攻击</span><br><span class="line">#用来存储session会话的状态，如下是为session分配一个名为one的10M的内存存储区，限制了每秒只接受一个ip的一次请求 1r/s</span><br><span class="line">  limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</span><br><span class="line">  limit_conn_zone $binary_remote_addr zone=addr:10m;</span><br><span class="line">  include       mime.types;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">#第三方模块lua防火墙</span><br><span class="line">    lua_need_request_body on;</span><br><span class="line">    #lua_shared_dict limit 50m;</span><br><span class="line">    lua_package_path &quot;/application/nginx/conf/waf/?.lua&quot;;</span><br><span class="line">    init_by_lua_file &quot;/application/nginx/conf/waf/init.lua&quot;;</span><br><span class="line">    access_by_lua_file &quot;/application/nginx/conf/waf/access.lua&quot;;</span><br><span class="line"></span><br><span class="line"> #设定请求缓存    </span><br><span class="line">  server_names_hash_bucket_size 128;</span><br><span class="line">  client_header_buffer_size 512k;</span><br><span class="line">  large_client_header_buffers 4 512k;</span><br><span class="line">  client_max_body_size 100m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #隐藏响应header和错误通知中的版本号</span><br><span class="line">  server_tokens off;</span><br><span class="line">  #开启高效传输模式   </span><br><span class="line">  sendfile on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #激活tcp_nopush参数可以允许把httpresponse header和文件的开始放在一个文件里发布，</span><br><span class="line">  积极的作用是减少网络报文段的数量</span><br><span class="line">  tcp_nopush     on;</span><br><span class="line">  #激活tcp_nodelay，内核会等待将更多的字节组成一个数据包，从而提高I/O性能</span><br><span class="line">  tcp_nodelay on;</span><br></pre></td></tr></table></figure>
<h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><h3 id="Nginx启动"><a href="#Nginx启动" class="headerlink" title="Nginx启动"></a>Nginx启动</h3><p>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</p>
<h3 id="Nginx停止"><a href="#Nginx停止" class="headerlink" title="Nginx停止"></a>Nginx停止</h3><p>ps -ef|grep nginx<br>kill -9</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/Linux环境下Mysql5.7的tar包形式安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/Linux环境下Mysql5.7的tar包形式安装/" itemprop="url">
                  Linux环境下Mysql5.7的tar包形式安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 16:37:30 / 修改时间：20:20:30" itemprop="dateCreated datePublished" datetime="2018-12-26T16:37:30+08:00">2018-12-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="Linux环境下Mysql5-7的tar包形式安装"><a href="#Linux环境下Mysql5-7的tar包形式安装" class="headerlink" title="Linux环境下Mysql5.7的tar包形式安装"></a>Linux环境下Mysql5.7的tar包形式安装</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>下载地址<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">Mysql官网</a></li>
<li>选择对应版本：<ol>
<li>系统选择 Red Hat Enterprise Linux / Oracle Linux 系统</li>
<li>版本选择 Oracl Linux 7 (x86, 64-bit) 版本</li>
<li>选择mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar版本下载</li>
</ol>
</li>
<li>上传到服务器<br> 使用相应工具上传到服务器，这里用的是SecureCRT 8.1上传。<br> (1)在服务器界面按快捷键(Alt+P).<br> (2)将文件mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar放到本地的文档目录下<br> (3)输入命令put -r mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar,此时文件会传输到root根目录，当然你也可以自己指定目录</li>
<li>将文件解压到指定目录，现在我们用的是/usr/local/mysql5.7</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>卸载centos7中自带的mariadb<br><code>rpm -qa|grep mariadb</code> //查询出来已安装的mariadb<br><code>rpm -e --nodeps</code> 文件名 //卸载mariadb,文件名为上述命令查询出来的文件</li>
<li><p>查看是否已经安装了mysql(新机器可以跳过)</p>
<p> <code>rpm -qa | grep -i mysql</code></p>
<p> 查找mysql文件<code>find / -name mysql</code></p>
<p> 使用<code>rm -rf mysql</code>文件路径删除</p>
<p> 删除分散mysql文件<code>find / -name mysql / # whereis mysql</code></p>
<p> 删除配置文档<code>rm -rf /etc/my.cnf</code></p>
<p> 再次查找机器是否安装mysql<code>rpm -qa|grep -i mysql</code></p>
</li>
<li><p>解压文件<br>tar -xvf mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar</p>
</li>
<li><p>创建相应用户组（可忽略）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#检查mysql是否存在      </span><br><span class="line">[root@hdp265dnsnfs ~]# rpm -qa | grep mysql     </span><br><span class="line">[root@hdp265dnsnfs ~]#      </span><br><span class="line"></span><br><span class="line">#检查mysql组和用户是否存在，如无创建    </span><br><span class="line">[root@hdp265dnsnfs ~]# cat /etc/group | grep mysql  </span><br><span class="line">[root@hdp265dnsnfs ~]#  cat /etc/passwd | grep mysql    </span><br><span class="line"></span><br><span class="line">#创建mysql用户组    </span><br><span class="line">[root@hdp265dnsnfs ~]# groupadd mysql   </span><br><span class="line">#创建一个用户名为mysql的用户并加入mysql用户组   </span><br><span class="line">[root@hdp265dnsnfs ~]# useradd -g mysql mysql   </span><br><span class="line">#制定password 为111111  </span><br><span class="line">[root@hdp265dnsnfs ~]# passwd mysql </span><br><span class="line">Changing password for user mysql.   </span><br><span class="line">New password:   </span><br><span class="line">BAD PASSWORD: The password is a palindrome  </span><br><span class="line">Retype new password:    </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
</li>
<li><p>写配置文件/etc/my.cnf<br> 命令：<code>touch my.cnf</code> 创建文件<br> 命令：<code>mkdir data</code> 创建文件夹<br> 命令：<code>vi my.cnf</code> 编辑文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysql] </span><br><span class="line">#设置mysql客户端默认字符集  </span><br><span class="line">default-character-set=utf8      </span><br><span class="line">[mysqld]    </span><br><span class="line">#设置3306端口   </span><br><span class="line">port = 3306     </span><br><span class="line">#设置mysql的安装目录    </span><br><span class="line">basedir=/var/mysql5.7    </span><br><span class="line">#设置mysql数据库的数据的存放目录    </span><br><span class="line">datadir=/var/mysql5.7/data   </span><br><span class="line">#允许最大连接数     </span><br><span class="line">max_connections=200     </span><br><span class="line">#服务端使用的字符集默认为8比特编码的latin1字符集    </span><br><span class="line">character-set-server=utf8   </span><br><span class="line">#创建新表时将使用的默认存储引擎     </span><br><span class="line">lower_case_table_names=1    </span><br><span class="line">max_allowed_packet=16M</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量<br>命令：<code>vi .bashrc</code> 打开配置文件<br>输入export PATH=$PATH:/usr/local/mysql5.7</p>
</li>
<li><p>初始化<br><code>/usr/local/mysql5.7/bin/mysqld --initialize-insecure --user=mysql</code></p>
</li>
<li><p>启动<br>命令：<code>/usr/local/mysql5.7/bin/mysqld_safe &amp;</code>启动<br>接着设置root的密码</p>
</li>
<li><p>检查是否成功<br>命令：<code>ps -ef |grep mysql</code> 检查进程<br>命令: <code>netstat -an |grep 3306</code>  检查默认端口</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/22/第96阶：Redis/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/第96阶：Redis/" itemprop="url">
                  第96阶：Redis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-22 16:37:30 / 修改时间：21:20:30" itemprop="dateCreated datePublished" datetime="2018-12-22T16:37:30+08:00">2018-12-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第96阶：Redis"><a href="#第96阶：Redis" class="headerlink" title="第96阶：Redis"></a>第96阶：Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有字符串，链表，集合和有序集合。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种排序功能。</p>
<p>Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 </p>
<p>redis提供两种方式进行持久化，一种是<strong>RDB持久化</strong>（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是<strong>AOF（append only file）持久化</strong>（原理是将Reids的操作日志以追加的方式写入文件）。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">redis持久化的几种方式</a></p>
<h3 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h3><ol>
<li>RDB持久化<br> RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161552843-904424952.png" alt="RDB持久化原理图"></li>
<li>AOF持久化<br> AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。<br><img src="https://images2017.cnblogs.com/blog/388326/201707/388326-20170726161604968-371688235.png" alt="AOF持久化"></li>
</ol>
<h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p>RDB存在哪些优势呢？     </p>
<ol>
<li><p>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p>
</li>
<li><p>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</p>
</li>
<li><p>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
</li>
<li><p>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
</li>
</ol>
<p>RDB又存在哪些劣势呢？</p>
<ol>
<li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
</li>
<li><p>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
</li>
</ol>
<h2 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h2><p><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis常用指菜鸟教程</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/第62阶：jvm虚拟机优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/第62阶：jvm虚拟机优化/" itemprop="url">
                  第62阶：jvm虚拟机优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-14 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-14T16:37:30+08:00">2018-12-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-18 21:20:30" itemprop="dateModified" datetime="2018-12-18T21:20:30+08:00">2018-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第62阶：jvm虚拟机优化"><a href="#第62阶：jvm虚拟机优化" class="headerlink" title="第62阶：jvm虚拟机优化"></a>第62阶：jvm虚拟机优化</h1><p><a href="https://www.bilibili.com/video/av31834249/?spm_id_from=333.788.videocard.17" target="_blank" rel="noopener">jvm虚拟机优化</a></p>
<h2 id="虚拟机桥接模式和NAT"><a href="#虚拟机桥接模式和NAT" class="headerlink" title="虚拟机桥接模式和NAT"></a>虚拟机桥接模式和NAT</h2><p>在桥接模式下。VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它能够訪问网内不论什么一台机器。你须要手工为虚拟系统配置IP地址、子网掩码，并且还要和宿主机器处于同一网段，这样虚拟系统才干和宿主机器进行通信。</p>
<p>使用NAT模式。就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来訪问公网。使用NAT模式能够实如今虚拟系统里訪问互联网。</p>
<p>注意：NAT模式和桥接模式不能相互连接</p>
<h2 id="java虚拟机的基本结构"><a href="#java虚拟机的基本结构" class="headerlink" title="java虚拟机的基本结构"></a>java虚拟机的基本结构</h2><p><a href="https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png" target="_blank" rel="noopener">JVM的基本结构及其各部分详解（一）</a></p>
<p><img src="https://images2015.cnblogs.com/blog/994276/201612/994276-20161218141127183-1877010567.png" alt="java虚拟机的基本结构"></p>
<ol>
<li><p>类加载子系统负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。</p>
</li>
<li><p>java堆在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的，这是一块与java应用密切相关的内存空间。</p>
</li>
<li><p>java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>垃圾回收系统是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理。</p>
</li>
<li><p>每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧信息，java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切相关。</p>
</li>
<li><p>本地方法栈和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用C编写）</p>
</li>
<li><p>PC（Program Counter）寄存器也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined</p>
</li>
<li><p>执行引擎是java虚拟机的最核心组件之一，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译技术将方法编译成机器码后再执行。 </p>
</li>
</ol>
<h2 id="jvm虚拟机参数"><a href="#jvm虚拟机参数" class="headerlink" title="jvm虚拟机参数"></a>jvm虚拟机参数</h2><p><a href="https://blog.csdn.net/momo_ibeike/article/details/76370428" target="_blank" rel="noopener">常用Java虚拟机调试和配置参数</a></p>
<ol>
<li><strong>-XX</strong>：对于系统级别的（jvm）配置，如配置日志信息、配置JVM使用什么样的垃圾回收器。</li>
<li><strong>非-XX</strong>：的基本上是应用层面上的配置。</li>
<li><strong>+</strong>：启用</li>
<li><strong>-</strong>：禁用</li>
<li><strong>-Xmn2g</strong>：设置年轻代(Eden)大小。</li>
<li>输入内存溢出信息、设置内存溢出路径。</li>
<li><strong>-Xss</strong>：线程最大栈空间，</li>
<li><strong>-XX:PermSize，-XX:PermSize=MaxPermSize</strong>：方法区大小。</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
<li><em>**</em>：</li>
</ol>
<p>基本策略：可以设置新生代的大小、新生代和老年代的比例。尽量将对象预留在新生代，减少老年代GC次数。</p>
<h2 id="负载均衡和反向代理"><a href="#负载均衡和反向代理" class="headerlink" title="负载均衡和反向代理"></a>负载均衡和反向代理</h2><p><strong>负载均衡</strong>（Load Balance）<br>其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>常见的负载均衡服务器有：<code>F5</code>,<code>LVS</code></p>
<p><strong>反向代理</strong>（Reverse Proxy）<br>是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>常见的反向代理服务器有:<code>nginx</code>,<code>haproxy</code></p>
<h2 id="GC清除对象"><a href="#GC清除对象" class="headerlink" title="GC清除对象"></a>GC清除对象</h2><p>当connection=null时，GC并没有立即回收对象，什么时候回收并不知道。除非手动调用GC回收方法。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p><a href="https://www.cnblogs.com/huajiezh/p/5769255.html" target="_blank" rel="noopener">深入理解java垃圾回收算法</a></p>
<ol>
<li>引用计数算法<br> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。<strong>缺点</strong>：相互循环引用会出现问题</li>
<li>标记-清除算法<br> 最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。<strong>缺点</strong>：首先，效率问题，标记和清除<strong>效率都不高</strong>。其次，标记清除之后会产生大量的<strong>不连续的内存碎片</strong>，空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
<li>复制算法<br> 目前用于新生代，将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<strong>缺点</strong>：可使用的内存降为原来一半。</li>
<li>标记压缩算法<br> 目前用于老年代</li>
</ol>
<h2 id="TLAB区域"><a href="#TLAB区域" class="headerlink" title="TLAB区域"></a>TLAB区域</h2>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/第09阶：多线程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/第09阶：多线程/" itemprop="url">
                  2018第09阶：多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-08T16:37:30+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-23 21:20:30" itemprop="dateModified" datetime="2018-12-23T21:20:30+08:00">2018-12-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第09阶：多线程"><a href="#第09阶：多线程" class="headerlink" title="第09阶：多线程"></a>第09阶：多线程</h1><h2 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h2><p><a href="https://www.bilibili.com/video/av31434494/?p=3" target="_blank" rel="noopener">2018百战程序员JAVA全系列终结版第09阶：多线程</a></p>
<h2 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run()和start()的区别"></a>run()和start()的区别</h2><ol>
<li>start：<br>　　用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。      </li>
<li>run：<br>　　run()方法只是类的一个普通方法而已，如果直接调用Run方法，<strong>程序中依然只有主线程这一个线程，其程序执行路径还是只有一条</strong>，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</li>
</ol>
<h2 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h2><p>如果一个对象只是用一次，可以使用匿名。</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实现类对象</span></span><br><span class="line">StartRun st = <span class="keyword">new</span> StartRun();</span><br><span class="line"><span class="comment">//创建代理类</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(sr);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></p>
<p>可以简化为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> StartRun()).start();</span><br></pre></td></tr></table></figure></p>
<h2 id="Thread类、Runnable接和Callable接口"><a href="#Thread类、Runnable接和Callable接口" class="headerlink" title="Thread类、Runnable接和Callable接口"></a>Thread类、Runnable接和Callable接口</h2><p>推荐使用Runnable接口，好处是：</p>
<ol>
<li>接口可以实现多个，突破单继承。</li>
<li><p>便于共享资源。因为一个线程只能启动一次，通过Thread实现线程时，线程和线程所要执行的任务是捆绑在一起的。而一个任务可以启动多个线程，通过Runnable方式实现的线程，实际是开辟一个线程，将任务传递进去，由此线程执行。</p>
</li>
<li><p>Callable接口<br>Callable接口用于juc并发编程</p>
</li>
</ol>
<ul>
<li>Callable规定的方法是call()，而Runnable规定的方法是run()。</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</li>
<li>call()方法可抛出异常，而run()方法是不能抛出异常的。</li>
<li>运行Callable任务可拿到一个Future对象。</li>
</ul>
<p>Future<br>    Callable任务返回Future对象。即：Callable和Future一个产生结果，一个拿到结果。Future 表示异步计算的结果。</p>
<p><a href="https://www.cnblogs.com/felixzh/p/6044371.html" target="_blank" rel="noopener">Callable接口、Runable接口、Future接口</a></p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda推导必须存在类型</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程只为用户线程服务，JVM不用等待守护线程结束才结束。而JVM默认会等用户线程结束才会结束。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>同步方法与同步块的区别：</p>
<p>1.同步方法<br>同步方法锁定的是this对象，不是方法。<br>即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。代码如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.同步代码块<br>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。代码如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 </p>
<h2 id="选区加锁对象"><a href="#选区加锁对象" class="headerlink" title="选区加锁对象"></a>选区加锁对象</h2><p>加锁的时候应该加在大对象上，防止调用对象不是同一个。</p>
<h2 id="Quartz使用"><a href="#Quartz使用" class="headerlink" title="Quartz使用"></a>Quartz使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建Scheduler工厂</span></span><br><span class="line">SchedulerFactory sf = <span class="keyword">new</span> SchedulerFactory();</span><br><span class="line"><span class="comment">//2. 从工厂中获取调度器</span></span><br><span class="line">Scheduler sched = sf.getScheduler();</span><br><span class="line"><span class="comment">//3. 创建JobDetail</span></span><br><span class="line">JobDetail job = newJob(HelloJob.class).withIdentify(<span class="string">"job1"</span>,<span class="string">"group1"</span>).build();</span><br><span class="line"><span class="comment">//时间</span></span><br><span class="line">Date runTime = evenSecondDateAfterNow();</span><br><span class="line"><span class="comment">//4. 触发条件</span></span><br><span class="line">Trigger trigger = newTrigger().withIdentify(<span class="string">"trigger1"</span>,<span class="string">"group1"</span>).start(runTime).build();</span><br><span class="line"><span class="comment">//5. 注册任务</span></span><br><span class="line">sched.schedulerJob(job,trigger);</span><br><span class="line"><span class="comment">//6. 启动</span></span><br><span class="line">sched.start</span><br></pre></td></tr></table></figure>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>只保证数据同步，当数据修改时立即通知其他持有者更新数据。比synchronized开销小，但不保证操作的原子性。已经很少使用了。</p>
<h2 id="使用double-checking和volatile进行单例设计"><a href="#使用double-checking和volatile进行单例设计" class="headerlink" title="使用double-checking和volatile进行单例设计"></a>使用double-checking和volatile进行单例设计</h2><p>单例模式：套路，在多线程环境下，对外存在一个对象。<br>在懒汉式基础上修改。</p>
<ol>
<li>构造器私有化，防止外部创建</li>
<li>提供私有的静态属性</li>
<li>提供公共的静态方法<br>静态方法示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLocking <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//再次检测，减少不必要的同步。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> !== instance)&#123;<span class="keyword">return</span> instance&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> DoubleCheckedLocking();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">&#125;instance</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="ThreadLoacl"><a href="#ThreadLoacl" class="headerlink" title="ThreadLoacl"></a>ThreadLoacl</h2><p>ThreadLoacl：分析上下文、环境、起点。    </p>
<ol>
<li>构造器：哪里调用就属于哪里，找线程体。</li>
<li>run方法：线程本身的。<br>InheritableThreadLoacl：继承上下文，环境的数据，拷贝一份给线程，起点</li>
</ol>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>原理：锁添加计数器，当加锁对象被访问时，判断是否锁定且为当前持有锁对象，否则wait();，是则计数器加1，当计数器为0时说明对象释放锁。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>独占锁，会导致其他线程挂起。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>没有锁，失败重试，直到成功。<br>乐观锁实现方式：Compare and Swap 比较并交换。<br>需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/07/Effective-Java-3rd第12章(85~90)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/Effective-Java-3rd第12章(85~90)/" itemprop="url">
                  Effective Java 3rd 第12章 序列化(85~90)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-07T16:37:30+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:51:00" itemprop="dateModified" datetime="2019-01-06T21:51:00+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="第12章-序列化"><a href="#第12章-序列化" class="headerlink" title="第12章 序列化"></a>第12章 序列化</h2><h2 id="第85条-尽量不要使用Serializable"><a href="#第85条-尽量不要使用Serializable" class="headerlink" title="第85条 尽量不要使用Serializable"></a>第85条 尽量不要使用Serializable</h2><p>序列化的一个基本问题是它的攻击面太大而无法保护，在对字节流进行反序列化的过程中，该方法可以执行来自这些类型的任何代码。不可信流的反序列化可能导致远程代码执行(RCE)、拒绝服务(DoS)和一系列其他利用。这些方法称为gadget。多个小工具可以协同使用，形成一个小工具链。有时会发现一个小工具链，它足够强大，允许攻击者在底层硬件上执行任意本机代码，只给攻击者提交精心设计的字节流进行反序列化的机会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deserialization bomb - deserializing this stream takes forever</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] bomb() &#123;</span><br><span class="line">    Set&lt;Object&gt; root = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; s1 = root;</span><br><span class="line">    Set&lt;Object&gt; s2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Set&lt;Object&gt; t1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Object&gt; t2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        t1.add(<span class="string">"foo"</span>); <span class="comment">// Make t1 unequal to t2</span></span><br><span class="line">        s1.add(t1); s1.add(t2);</span><br><span class="line">        s2.add(t1); s2.add(t2);</span><br><span class="line">        s1 = t1;</span><br><span class="line">        s2 = t2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialize(root); <span class="comment">// Method omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象图由201个HashSet实例组成，每个实例包含3个或更少的对象引用。整个流的长度为5744字节，但是在反序列化之前sun就已经耗尽了。问题是反序列化哈希集实例需要计算其元素的哈希码。root哈希集的2个元素本身就是包含2个哈希集元素的哈希集，每个哈希集元素包含2个哈希集元素，依此类推，深度为100层。因此，反序列化集合会导致hashCode方法被调用超过2100次。除了反序列化要花费很长时间之外，反序列化器没有任何出错的迹象。生成的对象很少，堆栈深度是有限的。</p>
<p>避免序列化被利用的最佳方法是永远不要反序列化任何东西。没有理由在您编写的任何新系统中使用Java序列化。</p>
<p>有许多其他的跨平台序列化方法，最常用的是以下两个：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>Json</th>
<th>protobuf</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>基于文本的</td>
<td>基于二进制的</td>
</tr>
<tr>
<td>优点</td>
<td>可读性好</td>
<td>高效</td>
</tr>
<tr>
<td>用途</td>
<td>完全是一种数据表示</td>
<td>提供模式(类型)来记录和强制适当的使用</td>
</tr>
<tr>
<td>备注</td>
<td>对于基于文本的表示非常有效</td>
<td>提供了一种可供选择的文本表示，以便在需要人类可读性的地方使用(pbtxt)</td>
</tr>
</tbody>
</table>
<p>总之，序列化是危险的，应该避免。如果您从头开始设计系统，那么可以使用跨平台的结构化数据表示，例如JSON或protobuf。不要反序列化不可信的数据。如果必须这样做，请使用对象反序列化筛选，但要注意，它不能保证阻止所有攻击。避免编写可序列化的类。如果你必须这样做，一定要非常小心。</p>
<h2 id="第86条-非常谨慎地实现可序列化"><a href="#第86条-非常谨慎地实现可序列化" class="headerlink" title="第86条 非常谨慎地实现可序列化"></a>第86条 非常谨慎地实现可序列化</h2><p>虽然使一个类可被序列化的直接开销非常低，甚至可以忽略不计，但是为了序列化而付出的长期开销往往是实实在在的。实现Serializable 接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。如果你接受了默认的序列化形式，这个类中私有的和包级私有的实例域将都变成导出的API的一部分，这不符合“最低限度地访问域”的实践准则（见第15条），从而它就失去了作为信息隐藏工具的有效性。</p>
<ol>
<li><strong>序列化会使类的演变受到限制</strong>，这种限制的一个例子与流的唯一标识符(stream unique identifier)有关，通常它也被称为序列版本UID (serial version UID )</li>
<li><strong>实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性(第85条)</strong>。无论你是接受了默认的行为，还是覆盖了默认的行为，反序列化机制(deserialization)都是一个“隐藏的构造器”，具备与其他构造器相同的特点。因为反序列化机制中没有显式的构造器，所以你很容易忘记要确保：反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，井且不允许攻击者访问正在构造过程中的对象的内部信息。依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受到非法访问（见第88条）。</li>
<li><strong>实现Serializable的第三个成本是，它增加了与发布类的新版本相关联的测试负担</strong>。当一个可序列化的类被修订的时候，要检查是否可以在新版本中序列化一个实例，然后在旧版本中反序列化。</li>
<li><strong>为继承而设计的类(项目19)很少实现可序列化，接口也很少扩展它</strong>。</li>
<li><strong>内部类(项目24)不应该实现可序列化</strong>。它们使用编译器生成的合成字段存储对封闭实例的引用，并存储来自封闭范围的局部变量值。这些字段如何与类定义对应是未指定的，匿名类和本地类的名称也是未指定的。因此，内部类的默认序列化形式是未定义的。然而，静态成员类可以实现序列化。</li>
</ol>
<p>如果一个类将要加入到某个框架中，井且该框架依赖于序列化来实现对象传输或者持久化，对干这个类来说，实现SeriaJizable接口就非常有必要。</p>
<p>总而言之，实现Serializable的易用性是似是而非的。除非类只在受保护的环境中使用，在这种环境中版本永远不必互操作，服务器永远不会暴露于不受信任的数据，否则实现Serializable是一个需要非常小心的严肃承诺。如果类允许继承，则需要格外小心。</p>
<h2 id="第87条-考虑使用自定义的序列化形式"><a href="#第87条-考虑使用自定义的序列化形式" class="headerlink" title="第87条 考虑使用自定义的序列化形式"></a>第87条 考虑使用自定义的序列化形式</h2><p>如果没有先认真考虑默认的序列化形式是否合达，则不要贸然接受。</p>
<p>如果一个对象的物理表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。使用默认序列化形式会有以下4个缺点：</p>
<ol>
<li>它使这个类的导出API永远地束缚在该类的内部表示法上。</li>
<li>它会消耗过多的空间</li>
<li>它会消耗过多的时间。</li>
<li>它会引起栈溢出。</li>
</ol>
<p>论你是否使用默认的序列化形式，当defaultWriteObject方法被调用的时候，每一个未被标记为transient的实例域都会被序列化。因此，每一个可以被标记为transient的实例域都应该做上这样的标记。在决定将一个域做成非transient 的乏前，请一定要确信它的值将是该对象逻辑状态的一部分。当一个实例被反序列化的时候，这些域将被初始化为它们的默认值(default value)：对于对象引用域，默认值为null,对于数值基本域，默认值为o,对于boolean域，默认值为false</p>
<p>总而言之，当你决定要将一个类做成可序列化的时候（见第86条），讲仔细考虑应该采用什么样的序列化形式。只有当默认的序列化形式能够合理地描述对象的逻辑状态时，才能使用默认的序列化形式；否则就要设计一个自定义的序列化形式，通过它合理地描述对象的状态。你应该分配足够多的时间来设计类的序列化形式，就好像分配足够多的时间来设计它的导出方法一样（见第51条）。正如你无法在将来的版本中去掉导出方法一样，你也不能去掉序列化形式中的域；它们必须被永久地保留下去，以确保序列化兼容性。选择错误的序列化形式对干一个类的复杂性和性能都会有永久的负面影响。</p>
<h2 id="第88条-保护性地编写readObjct方法"><a href="#第88条-保护性地编写readObjct方法" class="headerlink" title="第88条 保护性地编写readObjct方法"></a>第88条 保护性地编写readObjct方法</h2><p>构造器必须检查其参数的有效性（见第38条），并且在必要的时候对参数进行保护性拷贝（见第39条）。</p>
<p>总而言之，每当你编写readObject方法的时候，都要这样想：你正在编写一个公有的构造器，无论给它传递什么样的字节流，它都必须产生一个有效的实例。不要假设这个字节流一定代表着一个真正被序列化过的实例。虽然在本条目的例子中，类使用了默认的序列化形式，但是，所有讨论到的有可能发生的问题也同样适用千使用自定义序列化形式的类。下面以摘要的形式给出一些指导方针，有助千编写出更加健壮的readObject方法：</p>
<ul>
<li>对于对象引用埮必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属千这一类别。</li>
<li>对干任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。</li>
<li>如果整个对象图在被反序列化之后必须进行验证，就应该使用Objectlnput Validation接口[JavaSE6, Serialization]。</li>
<li>无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。</li>
</ul>
<h2 id="第89条-若想控制实例，使用Enum比readResolve"><a href="#第89条-若想控制实例，使用Enum比readResolve" class="headerlink" title="第89条 若想控制实例，使用Enum比readResolve"></a>第89条 若想控制实例，使用Enum比readResolve</h2><p>总而言之，你应该尽可能地使用枚举类型来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控(instance-co?trolled)的类，就必须提供一个readResolver方法，并确保该类的所有实例域都为基本类型，或者是transient的。</p>
<h2 id="第90条-考虑用序列化代理代替序列化实例"><a href="#第90条-考虑用序列化代理代替序列化实例" class="headerlink" title="第90条 考虑用序列化代理代替序列化实例"></a>第90条 考虑用序列化代理代替序列化实例</h2><p>总而言之，每当你发现自己必须在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/Effective-Java-3rd第11章(79~84)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Effective-Java-3rd第11章(79~84)/" itemprop="url">
                  Effective Java 3rd 第11章 并发(79~84)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-06T16:37:30+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:49:53" itemprop="dateModified" datetime="2019-01-06T21:49:53+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第11章-并发"><a href="#第11章-并发" class="headerlink" title="第11章 并发"></a>第11章 并发</h1><h2 id="第78条-同步访问共享的可变数据"><a href="#第78条-同步访问共享的可变数据" class="headerlink" title="第78条 同步访问共享的可变数据"></a>第78条 同步访问共享的可变数据</h2><p>为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。这归因于Java语言规范中的内存模型,它规定了一个线程所做的变化何时以及如何变成对其他线程可见。</p>
<p>不要使用Thread.stop，因为它本质上是不安全的。</p>
<p>当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。volatile修饰符就是一种可以接受的同步形式，但要正确地使用它可能需要一些技巧。</p>
<h2 id="第79条-避免过度同步"><a href="#第79条-避免过度同步" class="headerlink" title="第79条 避免过度同步"></a>第79条 避免过度同步</h2><p>依据情况的不同，过度同步可能会导致性能降低、死锁，甚至不确定的行为。</p>
<p>我们正企图在遍历列表的过程中，将一个元素从列表中删除，这是非法的。</p>
<p>将外来方法的调用移出同步的代码块来解决（异常和死锁)问题通常并不太困难。可以通过将外来方法的调用移出同步的代码块.事实上，要将外来方法的调用移出同步的代码块，还有一种更好的方法。自从Java 1.5发行版本以来，Java类库就提供了一个并发集合(concurrent collection), 见第81条。CopyOn WriteArrayList这是专门为此定制的。这是Array List的一种变体。<strong>通过重新拷贝整个底层数组，在这里实现所有的写操作</strong>。由干内部数组永远不改动，因此迭代不需要锁定，速度也非常快。如果大量使用，CopyOoWriteArrayList的性能将大受影响，但是对千观察者列表来说却是很好的，因为它们几乎不改动，并且经常被遍历。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetObserver&lt;E»observers=</span><br><span class="line"><span class="keyword">new</span> CopyOnWri teArrayL i st&lt;SetObserver&lt;E»();</span><br></pre></td></tr></table></figure></p>
<p>通常，你应该在同步区域内做尽可能少的工作，如果你必须要执行某个很耗时的动作，则应该设法把这个动作移到同步区域的外面，而不违背第78条中的指导方针。</p>
<p>如果你在内部同步了类，就可以使用不同的方法来实现高井发性，例如分拆锁(lock splitting)、分离锁(lock striping)和非阻塞(nonblocking)并发控制。如果方法修改了静态域，那么你也必须同步对这个域的访问，即使它往往只用千单个线程。</p>
<p>简而言之，为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法。更为一般地讲，要尽址限制同步区域内部的工作县。当你在设计一个可变类的时候，要考虑一下它们是否应该自己完成同步操作。在现在这个多核的时代，这比永远不要过度同步来得更重要。只有当你有足够的理由一定要在内部同步类的时候，才应该这么做，同时还应该将这个决定消楚地写到文档中（见第82条）。</p>
<h2 id="第80条-优先选择执行器、任务和流，而不是线程"><a href="#第80条-优先选择执行器、任务和流，而不是线程" class="headerlink" title="第80条 优先选择执行器、任务和流，而不是线程"></a>第80条 优先选择执行器、任务和流，而不是线程</h2><p>对于小型程序或负载较轻的服务器，执行器。newCachedThreadPool通常是一个不错的选择，因为它不需要配置，而且通常“做正确的事情”。</p>
<p>Executor框架被扩展为支持fork-join任务，这些任务由一种称为fork-join池的特殊类型的Executor服务运行。由fork joinask实例表示的fork-join任务可以被分割成更小的子任务，而组成ForkJoinPool的线程不仅可以处理这些任务，还可以相互“窃取”任务，以确保所有线程都处于繁忙状态，从而导致更高的CPU利用率、更高的吞吐量和更低的延迟。编写和调优fork-join任务非常棘手。并行流(Item 48)是在fork连接池之上编写的，假设它们适合当前的任务，则允许您轻松地利用它们的性能优势。</p>
<h2 id="第81条-并发工具优先于wait和notify"><a href="#第81条-并发工具优先于wait和notify" class="headerlink" title="第81条 并发工具优先于wait和notify"></a>第81条 并发工具优先于wait和notify</h2><p>并发集合为标准的集合接口（如List、Queue和Map)提供了高性能的并发实现。为了提供高并发性，这些实现在内部自己管理同步（见第67条）。因此，并发集合中不可能排除并发活动；将它锁定没有什么作用，只会使程序的速度变慢。</p>
<p>非不得已，否则应该优先使用ConcurrentHashMap而不是使用Collections.synchronizedMap 或者Hash table。<strong>只要用并发Map替换老式的同步Map,就可以极大地提升井发应用程序的性能</strong>。更一般地，应该优先使用并发梊合，而不是使用外部同步的集合。</p>
<p>有些集合接口已经通过阻寒操作( blocking operation ) 进行了扩展，它们会一直等待（或者阻寒）到可以成功执行为止。例如，BlockingQueue扩展了Queue接口，并添加了包括take在内的几个方法，它从队列中删除并返回了头元素，如果队列为空，就等待。</p>
<p><strong>同步器</strong>是一些使线程能够等待另一个线程的对象，允许它们协调动作。最常用的同步器是CountDownLatch和Semaphore。较不常用的是CyclicBarrier和Exchanger 。</p>
<p><strong>倒计数锁存器</strong>(Countdown Latch)是一次性障碍，允许一个或者多个线程等待一个或者多个其他线程来做某些事情。CountDownLatch的唯一构造器带有一个int类型的参数，这个int参数是指允许所有在等待的线程袚处理之前，必须在锁存器上调用countDown方法的次数。</p>
<p>对于间歇式的定时，始终应该优先使用System.nanoTime,而不是使用System.currentTimeMills。System.nanoTime更加准确也更加精确，它不受系统的实时时钟的调整所影响。</p>
<p>下面是使用wait方法的标准模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The st andard i di0t11 for using the wait 11ethod</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span> (&lt;condition does not hold&gt;)</span><br><span class="line">        obj .wait(); <span class="comment">//- (Releases lock, and reacquires on wakeup)</span></span><br><span class="line">    ... <span class="comment">//Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>始终应该使用wait循环模式来调用wait方法；永远不要在徙环之外调用wait方法</strong>。把wait调用<br>放在一个循环中，以避免在公有可访问对象上的意外或恶意的通知。</p>
<p>简而言之，直接使用wait和notify就像用”并发汇编语言”进行编程一样，而java.util.concurrent则提供了更吓级的语官。没有双由在新代码中使用wait和notify,即使有，也是极少的。如果你在维护使用wait和notify的代码，务必确保始终是利用标准的模式从while循环内部调用wait。一般情况下，你应该优先使用notify All,而不是使用notify。如果使用notify,诏一定要小心，以确保程序的活性(liveness) 。</p>
<h2 id="第82条-线程安全性文档化"><a href="#第82条-线程安全性文档化" class="headerlink" title="第82条 线程安全性文档化"></a>第82条 线程安全性文档化</h2><p>Javadoc并没有在它的输出中包含synchronized修饰符。因为在一个方法声明中出现synchronized修饰符，这是个实现细节，并不是导出的API的一部分。</p>
<p>一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别。</p>
<p>下面的列表概括了线程安全性的儿种级别。这份列表并没有涵盖所有的可能，而只是些常见的情形：</p>
<ol>
<li><strong>不可变的</strong><br> 这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String,Long和Biglnteger</li>
<li><strong>无条件的线程安全</strong><br> 这个类的实例是可变的，但是这个类有若足够的内部同步，所以，它的实例可以被并发使用，无儒任何外部同步。其例子包括Random和ConcurrentHashMap 。</li>
<li><strong>有条件的线程安全</strong><br> 除了有些方法为进行安全的并发使用而带要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.sy nchronized包装返回的集合，它们的迭代器(iterator ) 要求外部同步。</li>
<li><strong>非线程安全</strong><br> 这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap 。</li>
<li><strong>线程对立的</strong><br> 即使每个方法调用都被外部同步所包围，这个类对于并发使用也是不安全的。线程敌意通常是由于在没有同步的情况下修改静态数据而引起的。没有人故意写第82项:文档线程安全331线程敌对类;此类类通常是由于没有考虑并发性而导致的。当一个类或方法被发现是线程不友好的，它通常是固定的或不赞成的。第78项中的generateSerialNumber方法在没有内部同步的情况下是线程不友好的，如第322页所述。</li>
</ol>
<p>这些分类（除了线程对立的之外）粗略对应于《Java Concurrency in Practice 》一书中的<br>线程安全注觥(thread safety annotation) , 分别为<code>Immutable</code>、<code>ThreadSafe</code>和<code>NotThreadsafe</code>。上述分类中无条件和有条件的线程安全类别都涵盖在<code>ThreadSafe</code>注解中了。</p>
<p>私有对象锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Private l ock object i dio11 - thwarts denial-of-service attack</span></span><br><span class="line"><span class="keyword">private</span> ·<span class="keyword">final</span> Object lock= <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">synchroni <span class="title">zed</span><span class="params">(lock)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>私有锁对象模式只能用在无条件的线程安全类上。有条件的线程安全类不能使用这种模式。私有锁对象模式特别适用于那些专门为继承而设计的类（见第17 条）。</p>
<p>简而言之，每个类都应该利用字斟句酌的说明或者线程安全注解，渚楚地在文档中说明它的线程安全属性。synchronized修饰符与这个文档毫无关系。有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁”。如果你编写的是无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法。这样可以防止客户端程序和子类的不同步干扰，让你能够在后续的版本中灵活地对并发控制采用更加复杂的方法。</p>
<h2 id="第83条-慎用延迟初始化"><a href="#第83条-慎用延迟初始化" class="headerlink" title="第83条 慎用延迟初始化"></a>第83条 慎用延迟初始化</h2><p>虽然延迟初始化主要是一种优化，但它也可以用来打破类和实例初始化中的有害循环。延迟初始化就像一把双刃剑。它降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销。</p>
<p>当有多个线程时，延迟初始化是需要技巧的。如果两个或者多个线程共享一个延迟初始化的域，采用某种形式的同步是很重要的，否则就可能造成严重的Bug(见第66条）。本条目中讨论的所有初始化方法都是线程安全的。</p>
<p>在大多数情况下，正常的初始化要优先于延迟初始化。下面是正常初始化的实例域的一个典型声明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal initialization of an instance field</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br></pre></td></tr></table></figure></p>
<p>如果利用延迟优化来破坏初始化的彼环，就要使用同步访问方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lazy initialization of instance field - synchronized accessor</span></span><br><span class="line"><span class="keyword">private</span> FieldType field;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (field == <span class="keyword">null</span>)</span><br><span class="line">        field = computeFieldValue();</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果出于性能的考虑而需要对静态域使用延迟初始化，就使用lazy initialization holder class模式。保了类要到被用到的时候才会被初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lazy initialization holder class idiom for static fields</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> FieldHolder.field; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当getFiel~方法第一次被调用时，它第一次读取FieldHolder.field,导致FieldHolder类得到初始化。</p>
<p>如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式。如今，双重检查模式是延迟初始化一个实例域的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Double-check idiom for lazy initialization of instance fields</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FieldType result = field;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123; <span class="comment">// First check (no locking)</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                result= field;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="keyword">null</span>) <span class="comment">// Second check (with locking)</span></span><br><span class="line">                    field = result = computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时候，你可能需要延迟初始化一个可以接受重复初始化的实例域，它就是单重检查模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single-check idiom - can cause repeated initialization!</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FieldType result = field;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            field = result = computeFieldValue();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简而言之，大多数的域应该正常地进行初始化，而不是延迟初始化。如果为了达到性能目标，或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的延迟初始化方法。对千实例域，就使用双重检查模式, 对于静态域，则使用lazy initialization holder class idiom。对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式 。</p>
<h2 id="第84条-不要依赖线程调度程序"><a href="#第84条-不要依赖线程调度程序" class="headerlink" title="第84条 不要依赖线程调度程序"></a>第84条 不要依赖线程调度程序</h2><p>任何依赖于<strong>线程调度器</strong>来达到正确性或者性能要求的程序，很有可能都是不可移植的。要编写健壮的、响应良好的、可移植的多线程应用程序，最好的办法是确保可运行线程的平均数址不明显多于处理器的数址。</p>
<p>线程任务应适当地小并彼此独立，但又不能太小，否则分配开销也会影响性能。</p>
<p>线程不应该一直处于忙－等( busy-wait ) 的状态，即反复地检查一个共享对象，以等待<br>某些事情发生。</p>
<p>如果某一个程序不能工作，是因为某些线程无法像其他线程那样获得足够的CPU时间，那么，不要企图通过调用Thread.yield来“修正”该程序，Thread.yield没有可测试的语义，同一个yield调用在一个JVM实现上能提高性能，而在另一个JVM实现上却有可能会更差。</p>
<p>有一种相关的方法是调整线程优先级(thread priority),同样有类似的警告。线程优先级是Java平台上最不可移植的特征了。</p>
<p>简而言之，不要让应用程序的正确性依赖于线程调度器。否则，结果得到的应用程序将既不健壮，也不具有可移植性。作为推论，不要依赖Thread.yield或者线程优先级。这些设施仅仅对调度器作些暗示。线程优先级可以用来提高一个已经能够正常工作的程序的服务质县，但永远不应该用来“修正”一个原本并不能工作的程序。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/Effective-Java-3rd第10章(70~78)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小华">
      <meta itemprop="description" content="个人学习博客">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萌面超人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Effective-Java-3rd第10章(70~78)/" itemprop="url">
                  Effective Java 3rd 第10章 异常(70~78)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 16:37:30" itemprop="dateCreated datePublished" datetime="2018-12-05T16:37:30+08:00">2018-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-06 21:50:56" itemprop="dateModified" datetime="2019-01-06T21:50:56+08:00">2019-01-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="第10章-异常"><a href="#第10章-异常" class="headerlink" title="第10章 异常"></a>第10章 异常</h1><h2 id="第69条-只针对异常的情况才使用异常"><a href="#第69条-只针对异常的情况才使用异常" class="headerlink" title="第69条 只针对异常的情况才使用异常"></a>第69条 只针对异常的情况才使用异常</h2><p>总而言之，异常(exception)是为了在异常情况下使用而设计的。不要将它们用干普通的控制流，也不要编写迫使它们这么做的API。</p>
<h2 id="第70条-对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#第70条-对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="第70条 对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>第70条 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><p>Java程序设计语言提供了三种可抛出结构(throwable) : 受检的异常( checked exception ) 、<br>运行时异常( run-time exception ) 和错误( error ) 。</p>
<p>在决定使用受枪的异常或是未受检的异常时，主要的原则是：<strong>如果期望调用者能够适当地恢复，对于这种情况就应该使用受检的异常</strong>。</p>
<h2 id="第71条-避免不必要地使用检查过的异常"><a href="#第71条-避免不必要地使用检查过的异常" class="headerlink" title="第71条 避免不必要地使用检查过的异常"></a>第71条 避免不必要地使用检查过的异常</h2><p>在实践中， catch块几乎总是具有断言(assertion)失败的特征。异常受梒的本质并没有为程序员提供任何好处，它反而需要付出努力，还使程序更为复杂。</p>
<p>被一个方法单独抛出的受检异常，会给程序员带来非常高的额外负担。</p>
<p>“把受检的异常变成未受梒的异常”的一种方法是，把这个抛出异常的方法分成两个方法，其中第一个方法返回一个boolean,表明是否应该抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invocat,on with checked exception</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.action(args);</span><br><span class="line">&#125; <span class="keyword">catch</span>(TheCheckedException e) &#123;</span><br><span class="line"><span class="comment">// Handle exceptional condition</span></span><br></pre></td></tr></table></figure></p>
<p>重构为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invocation with state-testing 毗thod and unchecked exception</span></span><br><span class="line">    <span class="keyword">if</span> (obj. actionPermitted(args)) &#123;</span><br><span class="line">        obj.action(args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle exceptional condition</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第72条-优先使用标准异常"><a href="#第72条-优先使用标准异常" class="headerlink" title="第72条 优先使用标准异常"></a>第72条 优先使用标准异常</h2><p>Java平台类库提供了一组基本的未受梒的异常，它们满足了绝大多数API的异常抛出需要。</p>
<p>重用现有的异常有多方面的好处：</p>
<ol>
<li>最主要的好处是，它使你的API更加易于学习和使用，因为它与程序员已经熟悉的习惯用法是一致的。</li>
<li>第二个好处是，对干用到这些API的程序而言，<br>它们的可读性会更好，因为它们不会出现很多程序员不熟悉的异常。</li>
<li>最后（也是最不重要的）一点是，异常类越少，意味若内存印迹(footprint)就越小，装载这些类的时间开销也越少。</li>
</ol>
<p>不要直接重用Exception、RuntimeException、Throwable或Error。</p>
<p>常重用的异常有：</p>
<ol>
<li><em>llegalArgumentException</em><br>当调用者传递的参数值不合适的时候，往往就会抛出这个异常。例如，假设一个参数代表了“某个动作的重复次数”，如果程序员给这个参数传递了一个负数，就会抛出这个异常。</li>
<li><em>IllegalStateException</em><br>如果因为接收对象的状态而使调用非法，通常就会抛出这个异常。例如，如果在某个对象被正确地初始化之前，调用者就企图使用这个对象，就会抛出这个异常。</li>
<li><em>ConcurrentModificationException</em><br>如果一个对象被设计为专用千单线程或者与外部同步机制配合使用，一旦发现它正在（或已经）袚并发地修改，就应该抛出这个异常。</li>
<li><em>UnsupportedOperationException</em><br>如果对象不支持所请求的操作，就会抛出这个异常。</li>
</ol>
<table>
<thead>
<tr>
<th>异常</th>
<th>使用场合</th>
</tr>
</thead>
<tbody>
<tr>
<td>IllegalArgumcntException</td>
<td>非null的参数值不正确</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>对于方法调用而言、对象状态不合适</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>在禁止使用null的情况下参数值为null</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>数组下标参数值越界</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>在禁止井发修改的情况下，检测到对象的并发修改</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>对象不支持用户请求的方法</td>
</tr>
</tbody>
</table>
<h2 id="第73条-抛出与抽象相对应的异常"><a href="#第73条-抛出与抽象相对应的异常" class="headerlink" title="第73条 抛出与抽象相对应的异常"></a>第73条 抛出与抽象相对应的异常</h2><p>如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。为了避免这个问题，史高层的实现应该捕荻低层的异常，同时抛出可以按照高层抽象进行斛释的异常。这种做法被称为异常转译(exception translation )，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exception Translation</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    II Use lower-level abstraction to <span class="keyword">do</span> our bidding</span><br><span class="line">    . . .</span><br><span class="line">&#125; <span class="keyword">catch</span>(LowerLevelException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HigherlevelException( . . .);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>高层异常的构造器将原因传到支持链(chaining-aware)的超级构造器，因此它最终将被传给Throwable的其中一个运行异常链的构造器，例如Throwable (Throwable):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exception with chaining-aware constructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HigherLevelException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    HigherlevelException(Throwable cause) &#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总之，如果无法防止或处理来自较低层的异常，则使用异常转换，除非较低层方法碰巧保证其所有异常都适用于较高级别。异常链提供了两方面的优点:它允许您抛出适当的高级异常，同时捕获失败分析的底层原因(项目75)。</p>
<h2 id="第74条-每个方法抛出的异常都要有文档"><a href="#第74条-每个方法抛出的异常都要有文档" class="headerlink" title="第74条 每个方法抛出的异常都要有文档"></a>第74条 每个方法抛出的异常都要有文档</h2><p><strong>始终要单独地卢明受检的异常，并且利用Javadoc 的<code>@throws</code>标记，准确地记录下抛出每个异常的条件</strong>。<br>如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，而不是为每个方法单独建立文档.</p>
<p>总而言之，要为你编写的每个方法所能抛出的每个异常建立文档。对干未受检和受检的异常，以及对千抽象的和具体的方法也都一样。</p>
<h2 id="第75条-在细节消息中包含能捕获失败的信息"><a href="#第75条-在细节消息中包含能捕获失败的信息" class="headerlink" title="第75条 在细节消息中包含能捕获失败的信息"></a>第75条 在细节消息中包含能捕获失败的信息</h2><ol>
<li>要捕获失败，异常的详细消息应该包含导致异常的所有参数和字段的值。</li>
<li>不要在详细消息中包含密码、加密密钥等。</li>
</ol>
<h2 id="第76条-努力使失败保持原子性"><a href="#第76条-努力使失败保持原子性" class="headerlink" title="第76条 努力使失败保持原子性"></a>第76条 努力使失败保持原子性</h2><p>一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p>
<ol>
<li>对于在可变对象上执行操作的方法，获得失败原子性最常见的办法是，在执行操作之前检查参数的有效性（见第49条）</li>
<li>一种类似的获得失败原子性的办法是，调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。</li>
<li>第三种获得失败原子性的办法远远没有那么常用，做法是编写一段恢复代码( recovery code),由它来拦截操作过程中发生的失败， 以及使对象回滚到操作开始之前的状态上</li>
<li>最后一种获得失败原子性的办法是，在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。如果数据保存在临时的数据结构中，计算过程会更<br>加迅速，使用这种办法就是件很自然的事。</li>
</ol>
<p>一般而言，作为方法规范的一部分，产生的任何异常都应该让对象保持在该方法调用之前的状态。如果违反这条规则， API文档就应该清楚地指明对象将会处千什么样的状态。</p>
<h2 id="第77条-不要忽略异常"><a href="#第77条-不要忽略异常" class="headerlink" title="第77条 不要忽略异常"></a>第77条 不要忽略异常</h2><p>要忽略一个异常非常容易，只需将方法调用通过try语句包围起来，并包含一个<br>空的catch块：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Empty catch block ignores exception - Highly suspect!</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SomeException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>空的catch块会使异常达不到应有的目的</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">小华</p>
              <p class="site-description motion-element" itemprop="description">个人学习博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright"> &copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小华</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
